### 
[생활코딩 장고. 14강.]
(https://www.youtube.com/watch?v=pbKhn2ten9I&list=PLuHgQVnccGMDLp4GH-rgQhVKqqZawlNwG)
[점프투장고](https://wikidocs.net/70855)

웹페이지를 만드는 공장. 요청에 따라 웹페이지를 동적으로 생성.
공통적인 작업은 웹 프레임워크에게 맡기고 우리사이트가 해야할 본질에 집중하도록 만든 것
Django는 Flask, FastAPi와 더불어 파이썬진영의 대표적인 웹프레임워크
장고웹페이지의 공식 한줄 설명 : The web framework for perfectionists with deadlines. (마감에 쫓기는 완벽주의자를 위한 웹 프레임워크)

### 학습
여기저기 참고할만한건 많지만 공식사이트가 제일 좋다. 한글번역도 잘되어있다.
명령문에서는 linux탭, window탭이 있으니 잘 구분하자.
[공식](https://docs.djangoproject.com/ko/4.0/)
[설치](https://docs.djangoproject.com/ko/4.0/intro/install/)
[첫번째 장고앱 작성하기](https://docs.djangoproject.com/ko/4.0/intro/tutorial01/)


### 장고 vs 스프링
컴파일(안정성. 개발이후속도) vs 인터프리터(생산성)
RDBMS VS ORM
방대한 자료, 인력, 멀티쓰레드
장고는 메타데이터의 극치.

### 장고의 어플리케이션 개발 방식
### MTV(MVT) 패턴
 - ### Model 
     models.py
     django.db.models.Model클래스를 상속받은 클래스
     - 동작과 속성이 있으며 속성은 데이터베이스의 필드가 된다.
       일반적으로 하나의 모델은 하나의 데이터베이스 테이블에 매핑된다.
     - 디폴트로 SQLLite3엔진 사용. 다른 db로 바꾸려면 settings.py수정
     - DB접근 API(CRUD)를 자동 생성해줌
     - admin에 등록하면 해당 모델을 GUI환경에서 관리가능
     - <등록법>
        1. 기본.  admin.site.register(모델)
        2. 상속.  admin.site.register(앱명??, 클래스명)
        3. 장식자.   @admin.register(앱명??)
     - <옵션>
       - list_display : Admin 목록에 보여질 필드 목록
       - list_display_links : 목록 내에서 링크로 지정할 필드 목록 (이를 지정하지 않으면, 첫번째 필드에만 링크가 적용)
       - list_editable : 목록 상에서 수정할 필드 목록
       - list_per_page : 페이지 별로 보여질 최대 갯수 (디폴트 : 100)
       - list_filter : 필터 옵션을 제공할 필드 목록
       - actions : 목록에서 수행할 action 목록
    
     
     예) 
     from django.db import models

     class Person(models.Model):
        first_name = models.CharField(max_length=30)
        last_name = models.CharField(max_length=30)

    이렇게 하면 아래와 같은 데이터베이스 테이블을 생성한다.
    CREATE TABLE myapp_person (
        "id" serial NOT NULL PRIMARY KEY,
        "first_name" varchar(30) NOT NULL,
        "last_name" varchar(30) NOT NULL
    );
 - ### 뷰 ### View
     views.py 파일에 정의
     백엔드 소스. 스프링으로치면 컨트롤러부터 서비스까지
     request를 받고 템플릿을 로드해서 랜더링된 데이터와 리턴하는 역할을 한다.
 - ### 템플릿 ### Template
     스프링 MVC의 VIEW. 프론트엔드 소스
     templates디렉토리 하위에 *.html파일로 저장
     앱마다 templates폴더를 각각 만들어줘야 장고가 정확하게 구분한다.
     
     값을 출력    :  {{변수명}}
     문법        :  {%   코드    %}
     반복문의 종료 : {% endfor %}

---
---
정리하자면 장고의 개발 순서는 다음과 같다.

### 앱개발 순서
**프로젝트 생성 - 모델 작성(models.py, admin.py) - URL 작성(urls.py) - 템플릿 작성 (templates/html)- 뷰 작성(views.py)**
### 데이터흐름 순서
1. 클라이언트의 Request
2. URLconf가 URL분석
3. 담당할 뷰(로직) 결정
4. 뷰는 로직을 실행하고 DB가 필요하면 모델 사용
5. 뷰의 결과를 템플릿에 매핑
6. 뷰는 최종결과인 HTML파일을 클라이언트에 response



## 의문1
어떨때 python, 어떨때는 python3?
현재  python --version을 하면 Python 3.9.12 출력
      python3 --version을 하면 Python  출력


#### 파이썬 가상환경 생성
> python -m venv 가상환경명
virtualenv 툴은 시스템의 디폴트로 잡아준다.
파이썬3에서는 venv모듈이 기본포함되어있고, 옵션을 신경쓰지 않아도 명령줄에 사용된 파이썬을 그대로 인터프리터로 설정해준다.
파이썬의 버전과 여러 플러그인들의 버전을 프로젝트별로 별도 관리하기 위해 가상환경을 사용한다.
필요없는것들이 있으면 배포할때 불편해지는것도 한몫한다.


#### 가상환경 만들기
1. 가상환경을 모아둘 디렉터리를 만들고 이동
   > mkdir env,    cd env
   > pip install virtualenv
2. 특정 파이썬 버전을 사용하는 가상환경을 생성
   > **python -m venv 가상환경명**
   > virtualenv 가상환경명
3. 가상환경 적용 (스크립트 폴더안에서)
   > **cmd라면 activate**
   > **파워쉘이라면 ./activate.bat** 
   > **리눅스라면 source activate**
   > 오류가 나면 관리자권한으로 실행.    Set-ExecutionPolicy Unrestricted
   (가상환경명)$  으로 롬프트창이 바뀌는지 확인  
4. vscode라면 설치후 f1눌러서 interpreter 선택하는곳에서 가상환경폴더의 인터프리터 선택.

### 장고 설치
0. 설치되었나 확인
   (가상환경이라면 들어간거 확인후) python -m django --version
1. 파이썬 기본환경부터 업데이트
   python -m pip install --upgrade pip
   pip install --upgrade setuptools
2. 장고 설치(환경마다 최초에 한번)
> python -m pip install django (안되면 python3로 명령)
> 또는 **pip install Django**

### 프로젝트 설치   //최초의 예제는 mysite
1. 장고 프로젝트 생성.  (현재디렉토리에서 프로젝트경로에 장고 프로젝트 디렉토리 생성)
> **django-admin startproject 프로젝트명**   //Scripts폴더에서 
1. 설정파일 변경 **settings.py**
  ALLOWED_HOSTS = ['localhost', '127.0.0.1'], DATABASES, TIME_ZONE = 'Asia/Seoul', USE_TZ = False, LANGUAGE_CODE = 'ko-kr'
  STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')]
2. 프로젝트 실행
만들어진 프로젝트로 이동하여 manage.py있는 경로에서
**python manage.py runserver [포트번호]**
종료 : ctrl c


1. 앱만들기
**django-admin startapp 앱명**
python manage.py startapp bookmark
python manage.py startapp blog

1. db연동
**python manage.py migrate**

1. 계정생성
**python manage.py createsuperuser**
username : admin
password : human1234

1. 설정파일에 앱등록
apps.py에 있는 클래스를 settings.py의 INSTALLED_APPS에 추가


1. 새로운 앱에 대한 URL에 대한 매핑을 추가
#프로젝트 전역 설정 urls.py에 추가
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),  //어드민사이트에 넣기위해서는 항상 이줄
    path('shop/', include('shop.urls')),
]

1. 서버 실행
**python manage.py runserver [포트번호]**

#### path함수
필수인자 : rount, view
선택인자 : kwargs, name

#shop디렉토리 아래 url.py파일에 url 요청과 view함수 매핑 추가
from django.urls import path
from . import views

urlpatterns = [
    path('',  views.index)
]

3. url '/shop'요청에 대한 view 함수 추가
shop디렉토리 아래 views.py파일에  index 추가
from django.shortcuts import render
from django.http import HttpResponse

def index(request) :
    return HttpResponse("안녕하세요? Park's Shop에 오신것을 환경합니다.")





---
### 장고앱 만들기
> django-admin startapp 앱이름
하나의 프로젝트에는 앱이라고 하는 더 작은 단위가 있다.
각각의 앱안에는 urls.py와 view, model 이 있다.
urls.py를 통해서 요청을 누가 받도록 할것인지 설정
db와 직접 연결이 아니라 model 을 통해 편하게 통신하게 될거다.
path('index/', view.index)에서 view.index의 뜻은 views안의 index함수를 실행하겠다는 말이다.

서로연관된 로직들을 그룹짓고 싶어질거다.
장고의 앱들은 꼈다 뺐다가 할 수 있다.  앱을 현재 프로젝트에 포함시키기 위해서는 setting.py의 INSTALLED_APP부분에 추가해주면 된다.
     pollsConfig클래스는 polls/apps.py파일내에 있기 때문에
     polls.apps.PollsConfig가 된다.

### 장고 vs 노드
리얼타임(실시간)이 중요하거나 커스터마이징이 많이 필요하면 노드 
아니면 장고가 좋다.

### WebServer 와 WAS의 차이
WAS를 쓰면 정적 화면 파일들을 안만들어놓고 동적으로 만들어서 쓸 수 있다.
웹서버로 보여주면 준비되어있는것을 쓰는것이니 매우 빠르고 배울게 없다.
was로 보여주면 DB, JAVA, PYTHON등을 배워야되니 배울게 많고 느리다.
그러나 그럼에도 불구하고의 장점이 무엇이냐
1. 유지보수하기가 좋다. 공장만 수정하면 공장에서 만들어내는것 모두 바뀐다.
2. 개인화된 정보를 만들어줄 수 있다. 그 정보로 페이지를 생성하기 때문

### Routing
사용자가 요청한 정보를 누가 처리할것인지를 결정하는 것.
1. project폴더에있는 urls.py가 앱에 위임함
2. 앱에 있는 url.py가 view에 있는 특정함수로 위임함.
[소스코드 다운](https://github.com/egoing/django-tutorial-src)

--------------------------------------------------

### 명준MJ
3. [깃](https://www.youtube.com/watch?v=u7CyyHK2P_Q&list=PLi4xPOplIq7d1vDdLBAvS5PmQR-p6KwUz&index=3)
나는 볼 필요가 없음

4. [database](https://www.youtube.com/watch?v=-Nmtakm70Ro&list=PLi4xPOplIq7d1vDdLBAvS5PmQR-p6KwUz&index=4)
settings.py에서 필요로하는 db설정을 해주면된다.
INSTALLED_APP 부분에서는 프로젝트에 등록할 앱들을 등록해준다.
- 모델만들기  models.py
  - Question클래스.  질문(question), 발행일(publication date)
  - Choice클래스.  선택지(choice), 표(vote)

- ### [타입리스트](https://docs.djangoproject.com/en/2.2/ref/models/fields/#field-types)
- 모델 : 부가적인 메타데이터를 가진 데이터베이스의 구조.
  장고는 DRY원칙을 따르기 때문에 한곳에서 정의하고 자동으로 뭔가를 유도하는것이 목표. migration들은 모두 모델 파일로부터 유도된다.
- 앱등록
- **py manage.py makemigrations polls[앱이름]**   //설계도 만든다.
성공하면 아래와같은 로그 보인다.
  polls\migrations\0001_initial.py
    - Create model Question
    - Create model Choice
- **py manage.py migrate**    //데이터베이스에 모델을 적용
- API 가지고 놀기
  **py manage.py shell**
  # 단순히 python으로 실행안하고 위와같이 한 이유는 manage.py에 설정된 DJANGO_SETTINGS_MODULE 환경변수때문. 장고에서 동작하는 모든 명령을 대화식 파이썬쉘에서 그대로 시험해 볼 수 있다.
  >>> from polls.models import Choice, Question
  >>> Question.objects.all()

  >>> from django.utils import timezone
  >>> q = Question(question_text="What's news?", pub_date=timezone.now())
  >>> q.save()
  >>> q.id    ##명시하지않아도 자동으로 만들어줌
  >>> q.question_text
  >>> q.pub_date


  >>>Question.objects.filter(id=1)
  >>>Question.objects.filter(question_text__startswith='What')

5. [admin](https://www.youtube.com/watch?v=DRDuwNYT_Zk&list=PLi4xPOplIq7d1vDdLBAvS5PmQR-p6KwUz&index=5)
장고는 모델들을 화면에서 관리할수있게 관리용 페이지를 만들어준다. 
**py manage.py createsuperuser**    #슈퍼유저생성
(에러)Superuser creation skipped due to not running in a TTY.
텔레타이프라이터. 가상으로 만들어진 콘솔. 가상환경에서는 슈퍼유저생성 못하기 때문.
앞에 winpty 붙여주면됨.

유저네임 : admin
email : admin@example.com
비밀번호2번 : system1234
- 서버켜고 py manage.py runserver
- admin페이지 확인   localhost:8000/admin
- 관리사이트에서 poll 앱의 db띄우기
  - polls.admin.py 편집
  - from django.contrib import admin
    from .models import Question   #Qeustion객체가 관리 인터페이스를 가지고있다고 알려줌
    admin.site.register(Question)

6. [view사용] 로직을 담당
https://docs.djangoproject.com/ko/4.0/intro/tutorial03/
4개를 만들거다. 질문색인, 질문세부, 질문결과, 투표기능
뷰에서는 request라는 인자를 받고 HttpResponse를 리턴한다는것만 명심하면 큰줄기는 잡은거다.
  - polls.views.py 에 뷰 추가
  - render함수는 템플릿에 context를 채워넣어 HttpResponse객체와 함께 돌려줌
    - return HttpResponse(template.render(context, request))  라고 하던것을
    - return render(request, 'polls/index.html', context) 로 반환할 수 있다.
  - urls.py에 url패턴 매핑
  - 템플릿에 하드코딩된 url제거해줘야지 안그러면 url이 변경되면 템플릿 소스도 계속 바꿔줘야한다. 
  장고에서는 url마다 name을 명시할 수 있기 때문에 그걸 이용.

7. [form, generic view]
클래스 기반 뷰를 작성하면 코드가 줄어든다.
**중요**
<form action = "{% url 'polls:vote' question.id %}" method="post">
  {% csrf_token %}  //사이트간 위조요청방지. 프레임워크를 활용해서 간단하게 처리. 모든 form태그안에 넣어주면된다.
하면 해당 url에 걸려있는 view에서 받은 데이터를 처리한다.
urls.py를 보면 path('<int:question_id>/vote/', views.vote, name='vote')

----------------------------------------------------------
### form 
https://kimmeh1.tistory.com/213
https://developer-alle.tistory.com/333
- 장고는 2가지의 폼이 있다.
  - 일반폼(forms.Form)
  - 모델폼(forms.ModelForm) : Meta 이너클래스에 사용할 모델과 모델의 속성을 반드시 명시해줘야한다.

- 폼 클래스 만드는법 : html에서 input들을 일일이 만들기 번거롭기 때문에 사용
  1. 폼을 저장할 모델 정의
    ```python
    # models.py
    from django.db import models
    
    class Score(models.Model):
        content = models.CharField(max_length=100)
        score = models.IntegerField(default=0)
        movie = models.ForeignKey(Movie, on_delete=models.CASCADE)  #외래키

    ```
  2. forms.py에 클래스 정의 (폼을 사용하고자 하는 앱 디렉토리 하위에)
    ```python
    # forms.py
    from django import forms
    from .models import Score, Movie
    
    class ScoreForm(forms.Form):  ##일반폼. forms의 Form상속
        content = forms.CharField(
            max_length=100,
            label='한줄평',        #html에서 label태그를 의미
            widget=forms.TextInput(attrs={  #<input type="text">를 의미
                'class': 'score-content',
                'placeholder': '한줄평을 작성해주세요'
            })
        )
        score = forms.IntegerField(
            required=True,
            label='평점',
            min_value=0,
            widget=forms.NumberInput(attrs={
                'class': 'score'
            })
        )

    ```
    즉 위와같은 코드가 있으면 html에 아래와 같이 렌더링 된다.
    <label for="id_content">한줄평:</label>
    <input type="text" name="content" class="score-content" placeholder="한줄평을 작성해주세요" maxlength="100" required id="id_content">


  3. 폼을 렌더링할 템플릿
  [파일명: projects\mysite\templates\pybo\question_form.html]
  ```html
  <!-- detail.html -->
  <form action="{% url 'movies:detail' movie.pk %}" method="POST">
      {{ form.as_p }}
      <button typ="submit">
          등록
      </button>
  </form>
  ```

  > form.as_p가 붙은것은 <p>태그로 라벨과 인풋을 감싸라는 것. 안쓰면 줄바꿈없이 일렬로 렌더링된다.
  이외에도 as_table, as_ul 등이 있다. submit버튼은 자동으로 안만들어준다.

  4. 뷰에서 폼클래스 인스턴스 생성 및 객체 리턴
    ```python
    # views.py
    from .forms import ScoreForm
    
    def detail(request, pk):
        movie = Movie.objects.get(pk=pk)
        scores = movie.score_set.all()
    
        if(len(scores) == 0):
            messages.info(request, "아직 등록된 평점이 없습니다.")
            
      # 폼 처리 로직
        if request.method == 'POST':  #post 방식일때의 처리
            # score = request.POST['score']
            # content = request.POST['content']
            # Score.objects.create(score=score, content=content, movie_id=pk)
            form = ScoreForm(request.POST)
            if form.is_valid():   # 모든필드가 유효하다면
                score = form.cleaned_data['score']  #cleaned_data로 데이터를 꺼내서 저장
                content = form.cleaned_data['content']
                Score.objects.create(score=score, content=content, movie_id=pk) #원하는 로직을 처리
                return redirect('movies:detail', movie.pk)  #리다이렉트
        else:                         #get 방식일때의 처리
            form = ScoreForm()  # 빈 폼 생성
    
        return render(request, 'movies/detail.html', {'movie': movie, 'scores': scores, 'form': form})


    ```

### 에러
- django.urls.exceptions.NoReverseMatch: Reverse for 'detail' not found. 'detail' is not a valid view function or pattern name.
=> html의 하이퍼링크 잘못됨.
https://xfrnk2.github.io/django/django_url_name_not_found/


- File "C:\PycharmProjects\test5\home\models.py", line 4, in <module> class Promise(models):
  TypeError: module() takes at most 2 arguments (3 given)
-> 문제 : 많아도 2개의 아규먼트를 받아야 하는데 3개가 주어졌다고함.
-> 해결방법 : class Promise(models):      을
            class Promise(models.Model):  으로 변경

- TemplateDoesNotExist at /main/home/promise_form.html
-> 원인 : promise_form.html파일의 {{ form.as_p }}함수를 못찾음?
-> 해결방법 : templates폴더에 promise_form.html 생성 

### 날짜
https://alexpnt.github.io/2017/07/15/django-calendar/

