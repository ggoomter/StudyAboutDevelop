# 버전관리 시스템
Version Control System, VCS


# Git
https://book.coalastudy.com/python-django/week-6/level-up-1
- flsnrtmfmf aksems 리누즈 토발즈가 리눅스 오픈소스를 관리하기 위해 만들어졋다.
그간 리눅스 소스를 관리하던 툴 BitKeeper가 유료버전으로 바뀌자 홧김에 자기가 만들어도 이것보다 잘만들겠다 해서 2주만에 뚝딱만듬.
[리누즈 토발즈의 깃](https://dreamholic.tistory.com/79)

시간여행이 가능한 평행우주 생성.
아예 모든파일의 저장된 상태 자체를 바꿀 수 있다.
저쪽 우주에서 실험하던 실험적 기능이 마음에 들면 이쪽 우주로 가져올수있다.

- 다른시스템들은 주로 파일을 중심으로 변경된 내역을 관리한다.
깃은 데이터를 바라보는 관점이 완전히 다른데, 파일을 하나씩 별도로 보면서 차이점만 따로관리하는것이 아니라 프로젝트 전체를 스냅샷 형태로 관리한다.
변경되지 않은 파일은 다시 새로 저장을 하는것이 아니라 이미 저장되어 있는 파일에 링크만 걸어준다.
- 깃은 분산 버전관리 시스템이다. 이말은 데이터가 중앙 서버에만 있는것이 아니라 분산되어있는 모든 컴퓨터에 다 있다는 것이다.
그래서 인터넷이 없더라도 문제가 되지 않는다. 로컬에서 대부분의 작업을 할 수 있다. 나중에 연결되고 나서 git pull 혹은 git fetch를 하면 된다.
- 깃의 거의 모든작업은 깃 데이터베이스에 내용을 추가하는 작업이다. 이말이 무슨말이냐면 일단 커밋을 한 이후라면 다시 돌아올수 있는 길이 항상 존재하기 대문에 무엇이든지 하고싶은 일을 해도 된다는 말이다.


## 공식 자료
[pro-git](https://git-scm.com/book/ko/v2)

## 방법 2가지
GUI (소스트리)
CLI (커맨드)

## 준비
GIT, IDE, SOURCETREE
간혹 윈도우에서 아이콘이 안뜨면 C:Users\(내사용자명)\AppData\Local\SourceTree 에 있다.

## 깃의 파일 관리
- Tracked(관리대상)
    - Unmodified(수정하지 않음)
    - Modified (수정함)
    - Staged(커밋하면 저장소에 기록할)
- Untracked(관리대상 아님)

## 실행
1. 우리가 작업할 폴더를 연다.
2. 윈도우라면 shift 우클릭해서 현재폴더에서 power shell열기,
    맥은 터미널
3. 이 폴더를 깃이 관리하도록 만든다. = git init
4. 숨김파일 보이도록 설정
보기 - 옵션 - 숨김파일 표시
---
또는 아톰에서는 관리할 폴더를 연다음
vk-terminal 패키지 설치
ctrl + `
---
5. 현재시점 저장

## 용어
-commit : 가장 중요한 기능. 내컴퓨터에 저장하는 것이다.
    - local repository: 내 컴퓨터 저장소
    - remote repository:  원격 저장소
        대표적으로 GitHub이 있다. 개발자스러운 아이디를 잘지어야된다. 많이 노출되기 때문에
- stage : 캡슐안으로 넣는것. git add명령어를 쓰면 된다.
- branch : 가지. 다른 평행우주. 회사소스는 그대로 두고 나만 별도의 우주
           main브랜치는 기존기능을 유지/보수만 하면서 새로운 기능을 추가하려고 한다면 새로운 브랜치를 하나 따서 개발하는것이 정석.
- conflict : 같은곳을 변경했을때 양자택일 해야함.
- master
- head : 해당 브랜치의 제일 앞쪽 끝의 커밋
- HEAD : 현재 브랜치
- forward : 브랜치 헤드가 이동하는 방향
- fast forward : 현재작업중인 브랜치가 있고 다른 브랜치의 내용을 머지하는경우 발생하는 특별한 머지
    내가 작업한것을 마스터에 머지하려고 하는데, 마스터에는 내가작업한 내용보다 최근에 수정한 내용이 있어서 앞쪽에 속할때 mergecommit대신에 fast-foward(마스터의 내용을 내브랜치에 업데이트)한다.
- working tree : 내가 작업하고 있는 곳
- checkout : 워킹트리의 일부 혹은 전체를 업데이트 하는것.
- fetch : 리모트에서 로컬로 가져오기
- pull : 브랜치의 내용을 fetch를 한 후 머지하는것
- push : 서버에 저장하는것
- rebase : 현재 브랜치는 원래 어느 특정 커밋에서 시작된것이잖아. 이 현재 브랜치를 다시 부모의 브랜치의 head로 이동하는것.

## 커밋 메세지
미래의 나와 다른 개발자들을 위해서 꼼꼼하게 적어야한다.
첫줄에 간단하지만 명확하게 쓰고
한줄 비우고 그다음부터 자세한 내용





## 명령어 [링크](https://tech.10000lab.xyz/git/git-cheat-sheet.html)
- git init
깃의 명령어하에 두겠다. 평행우주 생성.
- git config --global user.name "내이름"
  git config --global user.email "내 메일주소"
- git status
현재 상태 살피기
밑에는 아직 담기지 않은것.
- git add -A   (All의 약어. 작업디렉토리에 있는 변경내역을 한번에 추가)    git add 파일명
타입캡슐에 담기
다시 git status 확인하면 묻을것들 색깔 바껴서 보임
- git commit -m "설명"    (message의 약어)
이전 커밋상태부터 현재상태까지의 변경이록이 기롯된 커밋을 추가한다.
무슨캡슐인지 설명해줘야됨
- push : 로컬의 수정내용을 리모트 리포지토리에 저장한다.
- pull : 브랜치의 내용을 fetch한후 merge.


- git log
이때까지 묻은 캡슐들을 본다.
git log --graph --all --decorate

- git diff    git add를 하기전의 파일만 가능하다.
- git diff --cached   스테이지 영역으로들어온 파일의 비교

- **reset**  **돌아가고싶은 지점을 선택하고 이 커밋의 현재 브런치를 초기화**
과거로 돌아가기
나혼자 작업하는 브랜치에서는 git reset을 사용해도 문제없다. 다른사람간의 코드가 공유될때 reset을 사용하면 헬게이트가 열린다.
  - hard : 과감한 방법 : reset 복원이후를 지운다. 커밋된 파일들중 tracked파일들을 working directory에서 삭제한다. (스테이지 영역에있는것을 포함)
  - mixed(default) :중간방법 :  커밋된 파일들을 working directory로 돌려놓는다. add전 상태로.
  - soft : 안전한 방법 : 커밋된 파일들을 staging area로 돌려놓는다. commit하기전 상태로.
  예) git reset --hard 번호6자리

- **revert**  ** 커밋 되돌리기 **
    커밋을 되돌리면서 되돌렸다는 새로운 커밋을 추가한다. 정석적인 되돌리기 방법이다.
    다른사람과 공유하는 브랜치에서 이전 커밋을 수정하고 싶을때 사용하면 좋다.
    git revert 번호7자리
- restore  파일명


- git branch 브런치명
- git branch            //브런치들을 보여준다.
- git checkout 브런치명  //브런치 이동
- git branch -D 브런치명    //브런치 삭제
- git merge
// 현재 머지로 다른 브런치 합치기. 메인프로젝트에 적용
- rebase    //브런치들 없애고 한줄로 딱 합쳐졌으면 좋겠다.
다른우주에서 가져오는 다른 방법
- clean

- git commit --amend -m "메세지"    마지막 커밋 메세지를 수정
- git commit --ammend       커밋하자마자 바로 버그를 발견한 경우같을때 이전 커밋에 포함시키기

## 소스트리
초보는 명령어보다 소스트리같은 GUI를 쓰는것이 좋다.
Atlassian에서 만든 gui 툴이다.

<설치>
Bitbucket : Atlassian에서 만든 웹기반 버전관리저장소 호스팅서비스
Mercurial : 크로스플랫폼 분산 버전관리도구. git과 거의비슷한 철학을 가지고있다.
	Git은 태생부터 수많은 병렬 브랜치를 전제로 설계되었다.
	Mercurial은 그런장점이 없는대신 배우고 사용하기 쉽도록 더 많은 노력을 들였다.
위의 2개 체크안함.    아이디, 이메일 입력,   ssh없음.

create - 플러스버튼 - 위치 선택 =
네모안에 + 버튼으로 캡슐에 담는다.
[생활코딩 소스트리](https://www.youtube.com/playlist?list=PLuHgQVnccGMCejd1l8C8oyZSYQDtkMRAg)

- 버전관리
Uncommited changes 는 아직 커밋되지 않은 변경사항이있다는것을 알려주는것이다.
Working Copy 탭으로가서 Staged Files로 올리고(캡슐 파묻고) 커밋하면된다.
- 하나의 버전에 여러개의 파일 관리 = 한캡슐에 파묻으면된다.(staged)
- 되돌아가는법
reset : 미래의 내역들을 지우면서 되돌아간다.
	히스토리에서 되돌아가고싶은 커밋버전 우클릭 - Reset current brach to this commit. 그러면 그 상태로 돌아간다.
	협업할때 이미 올라간 버전은 리셋하면 진짜 진짜 삽된다.
	- hard : 사이의 커밋 없어지고 커밋하지 않은 파일들같은거 다 지우고 진짜완전 그상태로 바꿈.
	-
	-
revert : 되돌아간다는 내역을 추가하면서 되돌아간다.
	되돌아가고싶은 버전이 아니라 잘못한 커밋버전에서 우클릭 - 커밋되돌리기(Reverse commit). 그러면 그버전의 보다 한버전 이전상태가 된다.
	revert는 역순으로 하나씩 해야지 문제가 없다. 4버전 이후의 모든 변경사항을 되돌리는것이 아니라 4버전에서 바뀐것만 되돌리는 것이기 때문에.
- 시간여행
시간이동하고싶은 버전 더블클릭
브런치 이동도 더블클릭. o로 현재 브런치가 표시된다.(실제 폴더 확인해보면 현재 브런치대로 시간여행되어있다.)

각각의 commit은 고유한 아이디가 있다. 긴것중에 앞의7글자만 뽑아서 리스트에서 보여준다. 이 커밋 id를 SHA라고도 한다.
- 비교
빨간색은 없어진것. 초록색은 생긴것.
이미지나 .hwp나 이런건 어떻게 비교할수있는가?
보고싶은 버전 파일 우클릭 - Open Current Version 하고, 비교하고싶은 버전의 파일 우클릭 - Open Selected Version 하면 각기다른 버전 2개열린다.
또는 비교전용 프로그램 사용
- 브런치 병합(merge)

- 원격 사용
1. github에 리모트 리파지토리 만들기
2. 소스트리에서 clone해서 리모트 리파지토리 주소넣으면 로컬주소 자동으로 만들어진다. 바꾸고싶으면 수정하면된다.
3. 클론버튼
4. 작업하고 commit
5. push

## Conflict 충돌
같은 파일을 두사람이 다른방향으로 수정해서 깃이 어느것을 선택해야할지 모를때 알려주고
해결하려면 유저가 무슨코드를 선택할지 수작업으로 정해줘야한다.


## 에러
- 새로만든 파일이 untracked files임
    -> 파일을 새로 만들면 untracked이며 add해줘야 추적대상으로 관리된다.
    -> 즉, 너도 관리대상이야 라고 지정해줘야한다. 관리대상인 애들만 다룬다.
    git status로 확인하면된다.


## 깃허브 github.com   pull request(merge request)
Remote - +계정추가 버튼 - 호스팅서비스를 Github로 변경하고 하단의 OAuth토큰 새로고침
- 초록색버튼 누르고 깃비밀번호 입력
Clone : 리모트를 로컬로 다운받는다.
풀 리퀘스트 : 마스터 브랜치에 병합하기전에 다른사람의 리뷰를 받고싶을때
    merge를 누르면 마스터브랜치에 병합된다.


## 깃헙 토큰 생성
프로필 우클릭 setting  -developer setting - Personal access tokens
