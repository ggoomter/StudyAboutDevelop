으로 갈라저 버릴것이라는 불안감이 팽배했다. 이때부터 웹통신 표준을 만들던 월드 와이드 웹 컨소시엄(W3C)에서 DOM 관련 작업을 하였다.
무수히 많은 언어에서 DOM을 구현하지만 웹 브라우저에서 DOM은 ECMAScript를 통해 구현된다.
* 각 마크업은 노드로 표현,  요소는 요소노드, 속성은 속성노드, 문서타입은 문서타입 노드 등 12가지 노드가있다.
* 모든 노드는 다른 노드와 관계가 있기 때문에 어느 노드든 도달할 수 있다. 
![DOM구조](DOM.jpg)
* 데이터타입 : document, element, nodeList, attribute, namedNodeMap
* window객체안의 document 만 DOM이라 부르고 외의 모든 객체를 BOM에서 처리한다.
  document는 브라우저에서만 접근되는데(브라우저와 노드js환경에서 각각 console로 찍어보자) 그말은 자바스크립트 자체의 요소가 아니라 브라우저라는 환경에서 제공된다는 말. 
  DOM도 BOM도 자바스크립트도 window라는 전역객체의 내부객체다.
  즉!! DOM API와 BOM API를 합쳐서 WEB API라고 한다.
* 요소핸들링
    - HTML로 선택    [MDN HTML셀렉터](https://www.w3schools.com/js/js_htmldom_nodes.asp)
    ```javascript
    document.getElementById('아이디명')
    document.getElementsByClassName('클래스명')    //배열이 리턴됨.
    document.getElementsByTagName('태그 이름')
    document.getElementsByName(이름 : name)
    ```

    - CSS문법으로 선택    [MDN 쿼리셀렉터](https://developer.mozilla.org/ko/docs/Web/API/Document/querySelector)
    //2022년 5월 선택자가 다를때 리턴 객체가 다르다는것을 알게됨
    //색상코드로 가져오면 rgb를 리턴하고 색상이름으로 가져오면 정상실행
    ```javascript
    document.querySelector('CSS선택자')
    document.querySelectorAll('CSS선택자')  //리스트
    document.querySelector("#main, #title, #footer");
    document.querySelectorAll("p.note, p.tip")  //리스트

 - (**주의**)요소를 가져오는지 요소의 리스트를 가져오는지 주의해야 한다.

    ```
- 예제1. 요소추가
```javascript
       window.onload = function() {

         // create a couple of elements in an otherwise empty HTML page
         var heading = document.createElement("h1");
         var heading_text = document.createTextNode("Big Head!");
         heading.appendChild(heading_text);
         document.body.appendChild(heading);
      }
```
- 요소삭제 : 부모.removeChild(자식);   요소.innerHTML = '';
            자기.remove();
- 속성추가 : 요소.setAttribute('키', '값')
- 클래스추가 : 요소.className += '클래스명';
- 원래 너비  : naturalWidth
- 예제2. css바꾸기
https://hianna.tistory.com/671


- 특이사항
1. 이미지 가로 너비를 반으로 줄이면 세로가 같이 줄어든다.
그래서 가로도 반, 세로로 반으로 해버리면 세로가 1/4이 된다.
한쪽만 지정하면 한쪽은 브라우저가 알아서 비율을 맞춘다.
1. p태그에는 value도 text도 없네. textContent로 가져옴

- dom 컨트롤
  - 정보
    - 요소.nodeName;  
    - 요소.nodeType;  //숫자가 나옴. 예를들어 3은 Textnode
  - CRUD
    - 요소.nodeValue; //텍스트가 아니면 null반환
    - 요소.innerHTML; //마크업 적용가능.  단점은 요소를 추가, 수정, 삭제할때마다 모든 html을 string으로 작성해야한다는 것
                     //그래서 document.createElement('태그명');    한다음 부모.appendChild(자식) 으로 넣어주는식이 더 좋다.
    - 요소.appned(컨텐츠) : 요소내부의 끝에 삽입
    - 요소.prepend(컨텐츠) : 요소내부의 시작부분에 삽입
      ```javascript
      testDiv.prepend('<div id="insertDiv"></div>');
      를 하면
      <div id="testDiv">
        <div id="insertDiv"></div>
      </div>
      ```
    - 요소.after(컨텐츠) : 요소뒤에 삽입
    - 요소.before(컨텐츠) : 요소앞에 삽입
    
    - 요소.insertBefore(새노드, 참조노드);      
          - //parent.insertBefore(ele, null);     //맨 끝에 삽입     
          - //parent.insertBefore(ele, parent.firstChild); //맨 앞에 삽입
    
  - 자식
    - 요소.childNodes;    노드리스트(모든노드) 반환
    - 요소.children;      HTMLCollection(요소만) 반환
    - 요소.firstChild;  
    - 요소.firstElementChild;
    - 요소.lastChild;
    - 요소.lastElementChild;
  - 형제
    - 요소.previousSibling; //이전 형제노드
    - 요소.previousElementSibling;  //이전 HTML요소노드
    - 요소.nextSibling;     //이후 형제노드
    - 요소.nextElementSibling;    //이후 HTML요소노드

##### XHTML
Extensible HyperText Markup Language는 HTML에 XML을 적용한 것.
HTML보다 엄격한 문법 규칙
XML과 XHTML에서는 <를 태그의 시작으로 간주하기 때문에 CDATA섹션으로 감싸는걸 많이 보게될것이다.

---
#### BOM (Browser Object Model)
* 자바스크립트를 통해 브라우저 창을 조작할 수 있게 하는 인터페이스
(뒤로가기를 한다든지, 홈으로 간다든지, 쿠키를 만들어서 다음 폼창을 입력할때 자동으로 가져와서 쓴다든지)
* Window, Screen, Location History, Navigator, Popup Alert, Timing, Cookies


---
#### 이벤트
- 자바스크립트는 이벤트를 기반으로 동작한다. 이벤트는 버튼클릭, 마우스 움직임, 웹페이지의 로드 등과 같은 어떠한 사건을 의미한다.
- 이벤트가 발생하는 시점이나 순서를 사전에 인지할수 없으므로 이벤트 감지, 그것이 감지 되면 실행할 로직을 미리 등록해두어야 한다.
- 이벤트 처리함수의 이름은 생각없이 on이벤트 명명법을 쓰지않도록 하자. 함수의 이름을 함수로 지은것과 비슷하다.
  핸들러가 걸려있음을 파악하고 전후문맥을 보고 정의코드도 읽고 해야한다. openSubMenu같이 지어주자. 잘만든 네이밍 하나 열 주석 안부럽다.
[w3이벤트설명](https://www.w3schools.com/js/js_htmldom_events.asp)
- 이벤트를 처리하는 2가지 방법 : 프로퍼티로 이벤트핸들러 등록,  메소드로 이벤트 리스너 전달
- 이벤트 핸들러와 리스너는 공식적으로 정의된 차이는 없다.
- **누구에게 어떤 이벤트가 발생하면 무엇을 하겠다.**
    - 이벤트 핸들러 : 이벤트가 발생했을때 처리를 담당하는 함수 = 이벤트 리스너에 등록된 콜백함수
                예) <input type="text" onclick="addNum(); printNum();"> //이런식으로 2개도 가능
                예) 객체.onclick = function(){}

    - 이벤트 리스너 : 이벤트가 발생하는지 듣고있는놈. 더 정교한 컨트롤이 가능하다. 이걸 쓰는 습관을 가지는게 좋다.
                예) 객체.addEventListener("click", function(event){
                    })
                //addEventListener(이벤트타입, 핸들러, 컨트롤옵션)
    - 마우스 이벤트 : click, dblclick, mousedown, moseup, mouseenter, mouseleave, mousemove, mouseout, mouseover
    - 키보드 이벤트 : keydown(모든키눌러짐), keypress(안보이는키가눌러짐), keyup(눌러진키가올라옴)
    - 윈도우 이벤트 : read, load, unload, resize, scroll, error
    - 인풋 이벤트 : change, focus, focusin, blur, select, submit
    - 실습 [w3 마우스 이벤트](https://www.w3schools.com/js/tryit.asp?filename=tryjs_addeventlistener_add_many2)

- 팁
    - onchange는 유저가 직접 입력한 값의 변경만 듣고있기 때문에 계산된 결과값이 변하는 경우 작동하지 않는다. 때문에 그런경우 아래와 같은 방법을 사용한다. 선택자.val('hello').change();
    2021년부터는 $("선택자").on("input", function() {} 이걸로 된다고 하는데 안된다.
- Event 인터페이스는 DOM에서 발생하는 사건을 처리한다.
- 한번은 이벤트가 인식자체가 안되는 이상한 문제가 있었는데
  $(".class").on("click", function(){  이런식의 코드를
  $(document).on("click", ".class", function(){  이런식으로 바꿔주면 된다.
  원인 : $(document).ready(function(){ 함수를 통해 페이지가 이미 로드 해오면서 진행이 됬기때문으로 예상됨

#### 이벤트 처리 중급. 콜백함수에 파라미터 넘기기
[참고](https://23life.tistory.com/158)
1. 객체.addEventListener(인자, 콜백함수); 를 보통 쓰는데 콜백함수에 인자가 필요하다고
   객체.addEventListener(인자, 콜백함수(인자)); 이런식으로 쓰면 당연히 안된다.
  콜백함수가 아니라 저 함수를 실행해버리니까 저 이벤트가 실행됐을때 콜백함수가 실행되게끔 해야되는 목적에 안맞게 된다.
2. 화살표 함수를 통해서 함수의 실행을 잠시 미루고 파라미터를 전달해보자.
객체.addEventListener('인자, ()=>
  함수실행(인자);
)
3. 보통 이벤트 객체를 넘겨주는데 그럼 어떻게 해야하나?
객체.addEventListener('인자, (event)=>
  함수실행(event, 인자);
)
이렇게 해주면된다.

#### 이벤트 버블링
> 한 요소에 이벤트가 발생하면 이 요소에 할당된 핸들러가 동작하고, 이어서 부모 요소의 핸들러가 동작하는것.
가장 최상단의 조상 요소를 만날때까지 이 과정이 반복되면서 요소 각각에 할당된 핸들러가 동작한다.
제일 깊은 곳에 위치한 요소의 이벤트가 부모 요소를 거슬러 올라가며 발생하는 모양이 마치 물속 거품과 닮았기 때문에 이런 이름이 붙었다.
자식에는 클릭이벤트를 안주고 부모에만 줘도 자식을 클릭했을대 부모의 이벤트가 발생한다.
부모와 자식에 이벤트를 주고 자식을 클릭하면 부모자식이 둘다 발생한다.
가장 안쪽의 요소는 타깃 요소라고 불리고 event.target 으로 접근할 수 있다.  this 는 event.currentTaget을 의미한다.
버블링을 중단하려면 event.stopPropagation();   또는 event.preventDefault(); 를 사용하면 된다. 그러나 꼭 필요한 경우를 제외하곤 버블링을 막지 않아야 한다. 아키텍처를 무너뜨리기 때문이다.
- <p> 태그는 이벤트버블링이 잘안되는데 검색해도 원인을 알 수 없다.

#### 이벤트 캡처링
이벤트가 하위 요소로 전파되는 매커니즘으로 버블링의 반대다.
캡처링을 막으려면 elem.addEventListener(..., {capture: true} 을 해야한다.
캡처링을 이용해야 하는 경우는 흔치않기 때문에 캡처링에 관한 코드를 발견하는 일은 거의 없다.

---
##### Web Storage(#### localStorage. 로컬스토리지. 웹db)
> 키와 밸류로 이루어져있다.
> 엄밀하게는 window.localStorage를 사용해야하지만, window 객체의 대부분의 속성이 그러하듯, 줄여서 그냥 localStorage로 접근 가능
> 브라우저의 url에 특정하여 저장한다. 저장된곳을 어느 url에서나 쓸수있는것이 아니다.
>오직 문자열(string) 데이터 타입만 지원. 숫자를 넣어도 문자열로 저장
> 위와 같은 문제를 피하기 위해서 많이 사용하는 방법은 JSON 형태로 데이터를 읽고 쓰는 것
```javascript
 localStorage.setItem('nums', JSON.stringify([1, 2, 3]))
undefined
 JSON.parse(localStorage.getItem('nums'))
[1, 2, 3]

//간단한 CRUD
var cat = localStorage.getItem('myCat'); //조회
localStorage.setItem('myCat', 'Tom'); //추가. 키, 밸류
localStorage.removeItem('myCat'); //삭제
localStorage.clear(); // 전체삭제

```
> 웹페이지를 닫을때 사라지게 하고싶다면 지워줘야한다.
```javascript
localStorage.removeItem('obj')
```


- localStorage.setItem("key", value); // 키에 데이터 쓰기
- localStorage.getItem("key");  // 키로 부터 데이터 읽기
- localStorage.removeItem("key"); // 키의 데이터 삭제
- localStorage.clear(); // 모든 키의 데이터 삭제
- localStorage.length;  // 저장된 키/값 쌍의 개수
```javascript
    function clickCounter() {
        if(typeof(Storage) !== "undefined") {
            if (localStorage.clickcount) {
                localStorage.clickcount = Number(localStorage.clickcount) + 1;
            } else {
                localStorage.clickcount = 1;
            }
            document.getElementById("counter").innerHTML = "카운터의 현재 횟수는 " + localStorage.clickcount + "입니다!";
        }
    }
```
---
#### JSON
- JavaScript Object Notation. 데이터포맷의 한 종류. String으로만 이루어져있다.
  즉, 단순히 데이터를 표시하는 표현방법일 뿐.
- **Javascript 객체 문법**으로 구조화된 데이터를 표현하기 위한 **문자 기반의 표준 포맷**. 구조화된 데이터를 표현하는것이기 때문에 함수는 전달못한다.
- 창시자 : Douglas Crockford
- 객체이름{키, 밸류}
- 1999년 ECMA3의 자바스크립트 객체의 형식에 큰 영향을 받아 만들어졌다.
- [샘플데이터](https://jsonplaceholder.typicode.com/)
- 웹브라우저위에서 동작하는 클라이언트와 서버가 어떻게 통신할지 정해놓은 규격이 HTTP(HyperText Transfer Protocol)
    - 클라이언트가 서버에게 *요청(request)* 할수있고 서버는 *응답(response)* 하는 방식으로 진행된다.
- 사용이유 : 데이터의 갯수, 데이터의 프로퍼티 가 100개, 1000개가 되면 그것들을 하나하나 변수로 만들수있을까?
- 장점 : 가장간단한 포맷(가볍다), 눈으로 읽기도 좋다(가독성). 언어나 플랫폼에 종속되지 않는다. 즉, 해당언어에만 특별한건 안쓰겠다는것.
- **문법. 표현법** : 객체는 {}, 배열은[], 속성은 "키" : 값의 쌍,  속성이 여러개일 경우 쉼표로 구분.  key는 항상 쌍따옴표로 감싸야한다.

- 예)
{
  "name" : "ggoomter",
  "age" : 35
}

- 속성추출법 : .키
- 마지막 콤마(후행 쉼표. Trailing commas)에 대한 설명 : https://heygyun.tistory.com/49
  JSON은 허락하지않고 자바스크립트는 허락한다.
  JSON은 허락하지않지만 브라우저에 따라 자동처리해주는경우가 있다.
```javaScript
let objData = [
  {
    "question": "저는 몇살 일까요?",
    "anwser": "1993년에 태어난 28살입니다."
  },
  {
    "question": "저의 혈액형은 무엇일까요?",
    "anwser": "O형 입니다."
  },
  {
    "question": "저는 어디에 살까요?",
    "anwser": "강남구 대치동에 살고 있습니다."
  },
  {
    "question": "저의 고향은 어디일까요?",
    "anwser": "부산입니다."
  }
];
console.log(objData);
let jsonData = JSON.stringify(objData);
console.log(jsonData);
```
- *직렬화* serialize : JSON.stringify 함수 사용. 
  객체를 json포멧(문자열)으로 변환.
  함수는 전달되지않는다. 자바스크립트에서만 특별하게 취급되니까 다루지 않음.
  두번째 파라미터로 전달하면 원하는 프로퍼티만 가져올수있음
  이것도 겁나 헷갈리는데 JSON이라는거 자체가 문자열의 형태일뿐이라는 본질에 집중하자.
  문자열로 만드는것이 stringify고 그것이 JSON포멧형태로 만드는 것이다.

- *역직렬화* deserialize.  JSON.parse함수 사용.
  json(문자열)을 객체로 변환
  gson, jackson은 JSON과 객체를 서로 변환시켜주는 라이브러리.
```javascript
  //객체
  let rabbit = {
      name : 'tori',
      color : 'white',
      size : 'small',
      birthDate : new Date(),
      jump : function(){
          console.log(`${this.name}은 jump를 합니다.`);
      }
  };

  //직렬화. json으로 만들기
  let json = JSON.stringify(rabbit);
  console.log(json);  //전체 출력
  let jsonPart = JSON.stringify(rabbit, ['name', 'color']);
  console.log(jsonPart);  //뽑은것만 출력


  //역직렬화. object로 만들기
  const obj = JSON.parse(json);
  console.log(obj); //변환했다가 변환. 함수 없어짐
  rabbit.jump();  //점프잘됨
  obj.jump(); //점프못함
```

- 팁 : 이쁘게 만들기, 비교하기 -> 울트라에딧
JSON Diff checker 다른점찾기: http://www.jsondiff.com/
JSON Beautifier/editor: https://jsonbeautifier.org/
JSON Parser 오브젝트 json 변화: https://jsonparser.org/
JSON Validator 유효성검사: https://tools.learningcontainer.com/json-validator/
줄이기


---

---
#### Collection
프로그래밍 언어가 제공하는 자료구조
자바스크립트가 제공하는 컬렉션 : Objects, Map, Set, Weak Map, Weak Set
원래 있던 객체, 배열.  현실세계를 반영하기엔 부족해서 2가지 추가됨.
객체의 특징은 키와 벨류,  배열의 특징은 순서(인덱스)
- ###### Set [집합]
    - (집합) 수학에서 배운 집합 완전 그거.
    - 목적 : 자신의 멤버인지 확인을 빨리하는것에 최적화.
    - 초기화 : new Set(데이터)
    - 내장함수 : has, size, add, delete, clear, forEach((value, valueAgain, set) => {    });
             반복잡업을 위한  keys, values, entries
                맵과의 호환성때문에 변수를 3개받도록 함. 이때문에 서로 교환하기 쉬워짐.
- ###### Map [맵](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Keyed_collections)
    [참고설명](https://maxkim-j.github.io/posts/js-map)
    - (키-밸류의 쌍)  객체는 키로 문자열,심볼만 가능, 맵은 객체가 가능.
    ```javaScript
    //객체로는 이런게 불가능하다.
    const errorMessageMap = new Map([
    [404, "페이지가 없습니다"],
    [500, "서버 오류입니다"],
    [401, "권한이 없습니다"],
    ])
    errorMessageObj.404         // unexpected number 에러
    ```
    - 맵 객체는 기존 객체와는 다르게 메소드만을 이용해 값을 넣고 뺀다.
    - 맵 객체는 객체의 프로퍼티를 자주 변경해야할 때 빛을 발한다.
    - 초기화 : new Map(데이터)
              배열.map(콜백함수)  
              예) const map1 = array1.map(x => x * 2);
    - 내장함수
        get(키) = 밸류를 리턴.   객체는 user.name  맵은 user.get("name")
        set(키, 벨류)
        has(키)
        delete(키)
        clear()
        size
        forEach(벨류, 키),
        for of   // for (const [key, value] of 맵)
        //객체에서는 for in이나 .keys()로 순회했는데 키만을 순회하기 때문에 값을 얻으려면 또 작업을 해야한다. 그 불편함때문에 Object.entries가 등장.
    - 팁 : map[key]는 맵을 일반객체처럼 쓰는것이기때문에 조금의 제약이 생기므로  map.get을 이용
    - 반복작업 : map.keys() – 각 요소의 키를 모은 반복 가능한(iterable, 이터러블) 객체를 반환합니다.
                map.values() – 각 요소의 값을 모은 이터러블 객체를 반환합니다.
                map.entries() – 요소의 [키, 값]을 한 쌍으로 하는 이터러블 객체를 반환합니다. 이 이터러블 객체는 for..of반복문의 기초로 쓰입니다.
    - Object 를 써야할지 Map 을 써야할지 고민이라면 다음과같은 경우를 고려한다.
        - 런타임 전까지 key 를 알 수 없을때
        - 모든 key 가 동일한타입 or 모든 value 가 동일한 타입
        - key-value 가 자주 추가되거나 삭제된다
        - 문자열 key 이외의 다른 key가 필요
        - 데이터가 순회되어야 한다
        위의 경우들이 있다면 Object 보단 Map 을 쓰는것을 고려해본다.
```javascript
let dictionary = new Map([
  ['Apricot', '살구'],
  ['Grapefruit ', "자몽"],
  ['Grape',    "포도"],
  ['WaterMelone', "수박"],
  ['Mango', '망고'],
  ['Banana', '바나나'],
  ['Apple', '사과'],
  ['Melon', '멜론'],
  ['Pear', '배'],
  ['Peach', '복숭아']
]);

// 키를 순회
for (let word of dictionary.keys()) {
  console.log(word);
}

// 값을 순회
for (let amount of dictionary.values()) {
  console.log(amount);
}

// [키, 값] 쌍을 대상으로 순회합니다.
for (let word of dictionary) { // dictionary.entries()와 동일합니다.
  console.log(word);
}

let map = new Map();

map.set('1', 'str1');   // 문자형 키
map.set(1, 'num1');     // 숫자형 키
map.set(true, 'bool1'); // 불린형 키

// 객체는 키를 문자형으로 변환한다는 걸 기억하고 계신가요?
// 맵은 키의 타입을 변환시키지 않고 그대로 유지합니다. 따라서 아래의 코드는 출력되는 값이 다릅니다.
alert( map.get(1)   ); // 'num1'
alert( map.get('1') ); // 'str1'

alert( map.size ); // 3
```



---
#### 비동기
자바스크립트는 싱글 스레드 아닌가요? 어떻게 비동기적 프로그래밍을 할수있죠?
자바스크립트 코어엔진 전용 특급 선로가 있고
기타 브라우저나 nodejs환경의 WEB API 선로가 있다. 거기서 비동기 처리를 한다.
비동기처리소에 도착하는 순서대로 Task Queue라는 하나의 선로에 콜백칸을 올려보낸다. 
자바스크립트 전용 특급 선로로 들어오게 된다. 





#### Ajax
[링크1](https://webclub.tistory.com/195)
- 사전지식
서버, URL, HTTP, 웹서비스

- 소개
**AJAX** (Asynchronous JavaScript And XML)
> 자바스크립트를 이용한 서버와 브라우저의 비동기적 데이터 교환방식
2005년 제시 제임스 개릿이 발표한 'Ajax : 웹 애플리케이션의 새로운 접근법'이라는 글이 이름의 유래다.
이 테크닉을 통해 '클릭하고, 기다린다'라는 웹 기초부터 변하지 않은 패러다임을 바꿀 수 있다고 주장했다.
이름이 Asynchronous JavaScript And XML이니까 XML을 통해서만 가능한가요? ㅠㅠ 아니다. AJAX가 개발될 당시에 개발을 주도했던 MS Outlook팀이 XML을 쓰고있어서 이름이 이렇게됐다.
굉장히 큰 실수.
함수나 오브젝트 이름을 정할때 이름이 얼마나 중요한건지 깨닫길 바란다.
데이터가 xml일 필요는 없다.
xml은 ,만으로 데이터를 구분짓기 어려울만큼의 큰 데이터를 다루게되면 적절한 xml 공부의 타이밍이다.
json이 xml과의 경쟁에게 이기고있다.


- 배경
1999년 MS가 처음으로 익스플로러5에 탑재. 꽤 오랜시간동안 화제가 되지 못했는데 2004년 구글의 지메일로인해 수면위로 부상. 페이지 전체를 새로고침하는것이 아님.
구글이 ActiveX, Flash, Java Applet 등 다른 vendor에 의존하지 않고 순수 자바스크립트를 통해 비동기로 화면을 동적으로 구성하는 것은 상당한 가치였으며 이를 통해 자바스크립트가 재평가를 받게됨

- 사용이유
1. 여러개의 함수를 동시에 병렬적으로 실행하기 위해서
2. 페이지를 전체 새로고침하는것이 아니라 필요한 부분만 가져온다.쉽게말하면 새로고침없이 서버에 요청을 주고받을수있는 자바스크립트 함수

- 기술
API(HTTP)로 브라우저에서 제공하는 *XHR*(XMLHttpRequest) 객체를 이용한다. 이것이 Ajax의핵심객체이며 MS에서 처음 개발하여 익스플로러5에 처음 탑재되었다.
Ajax이전에도 비동기통신을 사용하긴 했지만 이는 대부분 프레임이나 아이프레임을 사용한 것이었다. 1998년 부터 '원격 스크립팅'이라는 이름으로 쓰이고 있었다.
최근에는 **fetch** API(프로미스 기반이라서 콜백지옥에 안걸림)를 사용한다.
극 소수의 브라우저에서는 fetch가 안먹히는데 fetch polyfill로 검색해서 대신사용할 수 있는 기능을 검색해볼 수 있다.  그래서 브라우저 호환성을 확보할 수 있다.

아작스를 쓰기 위해서는 2가지 핵심적으로 신경써야될 정보가 있다.
1. 어떤 정보를 서버에게 요청할것인지
2. 서버의 응답이 오면 실행할 콜백함수


- 코드
1. 순수 자바스크립트
```javaScript
const xhr = new XMLHttpRequest();
  xhr.onreadystatechange = function(){
    if(this.readyState == 4  && this.status == 200){
      const response = JSON.parse(this.responseText);
      const table = document.getElementById('list');
      //response를 쓰는 코드
      document.getElementById("ajaxDom").innerText = response.price;

    }
  };
  xhr.open("GET", "https://codingapple1.github.io/price.json", true);
  xhr.send();
```
  //readyState 프로퍼티는 XMLHttpRequest 객체의 현재 상태를 나타낸다.
   0. UNSENT :   객체만 생성되고 보내지 않은 상태
   1. OPENED :   open()메소드가 성공적으로 실행됨 
   2. HEADERS_RECEIVED : 모든 요청에 대한 응답이 도착
   3. LOADING  : 요청한 데이터를 처리중
   4. DONE : 요청한 데이터의 처리가 완료되어 응답준비가 완료


1. jquery, axios 등 외부 라이브러리 사용
//Axios는 Promise based HTTP client for the browser and node.js
   node.js와 브라우저를 위한 HTTP통신 라이브러리
   비동기통신을 간으하게 해주고 promise객체를 리턴한다.
```javascript
function checkId(){
    let id = $('#id').val(); //id값이 "id"인 입력란의 값을 저장

      /* ajax로 구현 */
       $.ajax({
          url:'/user/idCheck', //Controller에서 인식할 주소
          type:'post', //POST 방식으로 전달
          data:{userId:id},
          success:function(outcome){
              console.log(outcome);
              if(outcome == 1){
                  $('.id_already').show();
                  $('.id_ok').hide();
              }else{
                  $('.id_ok').show();
                  $('.id_already').hide();
              }
          },
          error:function(){
              alert("에러입니다");
          }
      });
};
/* 데이터를 json형태로 안넘겨주고 하나만 넘겨주면 백엔드에서는 value가 아니라 key로 쓰이게된다. */

백엔드쪽
/* 아이디 중복검사 처리 */
@PostMapping("/idCheck")
@ResponseBody
public int idCheck(@RequestBody String userId) {
    log.info("검사할 id : " + userId);
    int cnt = uService.idCheck(userId);
    System.out.println("중복검사결과 : "+cnt);
    return cnt;
}

또는 @RequestParam
```


```javascript
        // ajax로 서울 미세먼지 공공데이터 받아와서 화면에 뿌려주기
        function dust(){
            
            $.ajax({
            type:"GET",
            url:"http://openapi.seoul.go.kr:8088/6d4d776b466c656533356a4b4b5872/json/RealtimeCityAir/1/99",
            data:{},
            success:function(response){
                console.log(response)
                // $("#name").empty();
                let dust=response["RealtimeCityAir"]["row"];
                for(let i=0; i < dust.length ;i++){
                    let gu_name =dust[i]["MSRSTE_NM"];
                    let stateOfDust=dust[i]["IDEX_MVL"];
                    if(stateOfDust<100){
                        let str_dust=`<li>${gu_name} : ${stateOfDust}</li>`;
                        $("#name").append(str_dust);
                    }
                }
                console.log(response)
            }
        })
        }
```

1. fetch  사용
```javascript
fetch('https://codingapple1.github.io/price.json')
  .then((response)=>{
    if(!response.of){
      throw new Error('400아니면 500 에러남');
    }
    return response.json();
  })
  .then((결과)=>{
    console.log(결과);
  })
  .catch(()=>{
    console.log('에러남');
  })
```
- 정리파일들
[생활코딩 ajax 코드](https://github.com/web-n/web2_javascript)
  해시뱅, pjax
[jqeury ajax 공식](https://api.jquery.com/category/ajax/low-level-interface/)
[fetch설명](https://ko.javascript.info/fetch)
[feth설명2](https://www.daleseo.com/js-window-fetch/)
[fetch설명3](https://velog.io/@jongsunpark88/fetch.-%EC%84%9C%EB%B2%84%EC%99%80%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%ED%86%B5%EC%8B%A0%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%9C-%ED%95%A8%EC%88%98-%EA%B7%B8%EB%A6%AC%EA%B3%A0-HTTP)
[fetch좋은설명](https://velog.io/@prayme/Fetch-API)
[비동기통신 기술들 비교 - 굳](https://devscb.tistory.com/66)
[모질라 fetch설명](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch)
[fetch와 바닐라js로 데이터 넘기기](https://gomakethings.com/how-to-send-data-to-an-api-with-the-vanilla-js-fetch-method/)
[바닐라js로 ajax깔끔](https://kim-oriental.tistory.com/12)

- 구현에서 유의사항
  1. 인코딩
  2. 넘길려는값 자바스크립트에서 일단 찍어보기
  3. 받아온값 서블릿이나 컨트롤러에서 찍어보기
  4. get, post 방식 유의
  5. ajax의 url부분은 절대주소로 하는게 마음 편함


- ###### XML
    - 계속 XML이라는 단어가 등장하는데 뭔가요?
    - XML(eXtensible Markup Language)은 W3C에서 개발.  HTML처럼 데이터를 보여주는 목적이 아닌, 데이터를 저장하고 전달할 목적으로 만들어짐. 설정파일로 많이 쓰임
    - XML은 새로운 태그를 만들어 추가해도 계속해서 동작하므로, 확장성이 좋음

- XMLHttpRequest의 핵심 메소드
    - open(method, url, [async:true])
        매개변수를 초기화하는 메서드
    - method : 데이터 전송방식(GET/POST)
    - url : 요청대상 URL 입니다.
    - async : 요청에 대한 응답을 기다리는 방식을 나타냅니다.   비동기(true: 기본값)와 동기(false) 방식이 있습니다.
    - send(data)
        실제로 HTTP request를 실행하는 메서드
    - onload : 응답데이터를 다 읽어들였을때 발생함.
    - onreadystatechange : reaDyState가 계속 변하는것을 체크함.

- XMLHttpRequest의 핵심 프로퍼티
  - onreadystatechange : 준비되면 실행할 콜백함수 정의
  - readyState : XMLHttpRequest의 상태 저장.
      - 0 : 초기화안됨
      - 1 : 서버연결됨
      - 2 : request 받음
      - 3 : request 처리중
      - 4 : request처리완료하고 response 준비
  - responseText : 스트링으로 된 response 데이터
  - responseXML : XML로 된 response 데이터
  - status : request에 대한 상태 번호
      - 200 : OK
      - 403 : forbidden
      - 404 : not found
    - statusText : 상태번호에 대한 값을 문자열로


- 유의1
화면에서 undefined나 object, null같은거 뜨는 문제
원인 : dataType : "json" 이라 해놓고
백엔드의 결과로 String 을 받거나 등등 데이터 형식이 안맞기 때문.
(**중요**)즉 dataType 에는 받을 형식의 데이터 : html, json, jsonp, script, text
//전송받은 데이터를 변환시킬 컨텐츠 타입


- fetch코드 상세 해석
fetch는 promise기반으로 만들어졌고 ES6부터 js의 내장라이브러리
POST방식이라면 method:'POST', body : JSON.stringify({ 키 : 밸류, 키2 : 밸류2})
   넘겨줘야 한다.
/* 1. 버튼클릭하면 서버로부터 정보를 받아오는 fetch함수 생성.*/
[또 참조할곳](https://yeri-kim.github.io/posts/fetch/)
/* 원본. 힘들지만 타이핑치기. html파일 만들고 fetch라는 버튼 만들어서 onclick달기 */
```javaScript
fetch('data/html').then(function(response){
    response.text().then(function(text){
        alert(text);
    })
})

또는
fetch("https://jsonplaceholder.typicode.com/posts/1")
  .then((response) => response.json())
  .then((data) => console.log(data));
```

/* 2. 해석해보자. */
fetch는 첫번째인자로 url, 두번째인자로 옵션객체를 받고,    리턴으로 Promise 객체를 반환한다.
API호출이 성공하면 response객체를 resolve하고 실패하면 error객체를 reject한다.
응답객체로부터 status, headers, body 등을 읽어올 수 있다.
fetch()함수는 브라우저의 window객체에 소속되어있다.
요청전문을 JSON포멧으로 직렬화하여 body옵션에 설정해준다.
응답객체의 json()메서드를 호출하면 응답전문을 객체 형태로 얻을 수 있다.

fetch(파일명) = 웹브라우저야 서버한테 파일명을 요청해줘
.then  = 서버가 응답을 해줄건데 시간이 많이 걸릴수 있다. 그 시간동안 기다리지 않고 다른일을 하다가 작업이 **끝나면 콜백함수 실행**시켜줘. 바로 이것이 비동기. Ajax의 어싱크로노스.
첫번째 then은 요청이 성공할경우 response객체를 받아 json형태로 파싱
두번째 then은 json형태의 응답 body의 데이터를 출력
catch는 요청이 완료되지 못할 때 에러 처리
Fetch는 브라우저가 제공하는 api 라서 사용가능하고 then은 fetch안에 있는거라서 쓸수있다.
then안에는 콜백함수가 올거라고 미리 정의되어있고 그 인자는 파라미터를 하나 받을건데 response라는 객체를 줄거라고 정해져있다. 사용설명서를 보면 그렇게 적혀있다.

```javaScript
//그래서 가장 쉬운 함수형태는 아래와같다.
function loadItems(){
    return fetch('data/data.json').then(response => console.log(response));
}

//그리고 가장 많이 쓰는 형태는 다음과 같다.
function loadItems(){
    return fetch('data/data.json')
        .then(response => response.json())
        .then(json => json.items);
}
```


/* 3. 원본 소스를 이해했으니 바꿔보자. */
```javaScript
1. 함수로 분리
fetch('data/html').then(콜백함수)
    이니까
fetch('data/html').then(callbackMe)
로 변환된다. 함수를 호출하는것이 아니라 함수명을 전달하는것에 유의.

선언형이였으면
function callbackMe(response){
    response.text().then(function(text){
        alert(text);
    })
}

표현형이였으면
var callbackMe = function(response){
    response.text().then(function(text){
        alert(text);
    })
}


3. callbackMe함수 업그레이드 : 데이터확인
function callbackMe(response){
    console.log(response);  //어떤 데이터가 담겨오는지 확인. status가 있는거 확인
    response.text().then(function(text){
        alert(text);
    })
}

4. callbackMe함수 업그레이드 : 결과값에 따라 분기처리
function callbackMe(response){
    if(response.status == '404'){
        alert("해당 파일이 없습니다.");
    }else{
        response.text().then(function(text){
        alert(text);
        })
    }
}

5. callbackMe함수 업그레이드 : alert가 아니라 HTML요소에 넣어서 보여주기
function callbackMe(response){
    if(response.status == '404'){
        alert("해당 파일이 없습니다.");
    }else{
        response.text().then(function(text){
            document.querySelector('article').innerHTML = text;
        })
    }
}

6. 데이터 가져와야할 css, javascript에도 적용하고 네트워크 확인
```

- ajax 에러 모음
에러1. CORS에러. 로컬에서 json파일을 불러오니 'null' has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes
=
 보안때문에 막아놓은것.
 해당위치에서 파일을 더블클릭한것과 //file:///E:/%ED%9C%B4%EB%A8%BC%EA%B5%90%EC%9C%A1%EC%84%BC%ED%84%B0/WEB/apache-tomcat-9.0.50/apache-tomcat-9.0.50/webapps/ROOT/%EA%BB%8D%EB%8D%B0%EA%B8%B0.html
 서버를 켜서 localhost로 들어간것은 다르다.
SOP (Same Origin Policy - 동일 출처 정책)
이유 : 먼저 MDN의 javascript modules에 관한 설명에 따르면 문제가 된 부분같이 type을 module로 설정한`<script>` 태그가 포함된 HTML 파일을 로컬에서 로드할 경우 자바스크립트 모듈 보안 요구사항으로 인해 CORS 오류가 발생한다고 합니다. 그 때문에 ajax로 요청한 것임 아님에도 불구하고 CORS 오류가 발생.
로컬의 리소스를 요청할 때의 origin(출처)은 null이다
해결법1 : tomcat으로 로컬서버 켬. 웹서버의 기본포트인 80으로 변경
해결법2 : 헤더에 Access-Control-Allow-Origin : '*'

에러2.  Unexpected token e in JSON at position 32
원인 : JSON파일내용에 형식이 안맞는게 있음.

에러3. object, object이런식으로 나올때
해결 : JSON.stringify(객체) 를 써서 JSON형태로 변환

에러4. Uncaught SyntaxError: Unexpected token < in JSON at position 0
원인 : 백엔드쪽에서 단순 문자열을 보내주고있을때 즉, JSON형태가 아니라 문자열하나인데 response.json()으로 파싱을 해주려고 하니 발생
해결 : https://iborymagic.tistory.com/78
그럴때는 response.json()대신 response.text()로 변환해주면된다.

에러5. 400 에러
원인 : Bad Request. 클라이언트에서 넘어온 파라미터가 이상함.

에러6. org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver - Resolved [org.springframework.web.bind.MissingServletRequestParameterException:
  **Required String parameter 'userId' is not present**]
원인 : @RequestParam은 url상에서 데이터를 찾기때문에 get에 사용한다. post로 전달해줬을때는 @RequestBody 사용

##### PJAX
pushState + ajax
검색엔진에 검색되게 끔 해주는 ajax
---

#### tomcat 톰캣
가장 대표적인 무료 웹서버.
- 톰캣을 설치하려면 자바와 자바홈이 설정되어있어야 한다.
  그래서 우리는 live-server package를 깔았다.
  단축키는 ctrl alt 3 ~8
  Packages탭에서 끄고 켜고 할수있다.
- 첫페이지
  web.xml을 실행하는데 이파일안에 welcome-file이 시작페이지를 설정하는곳이다.
  webapps/ROOT폴더에 필요한 리소스들 바꿔놓고 시작 페이지를 변경한다음
  server.xml에서 포트 확인한다음
  웹브라우저에서 localhost:8080을 입력.






---
##### 프로토타입 (원형 : 원래의 형태)
[모질라링크](https://developer.mozilla.org/ko/docs/orphaned/Web/JavaScript/Inheritance_and_the_prototype_chain)
한번듣고 잊어도된다. 사용할 기회도 흔치 않다. 너무 이해하려고 노력안해도된다. 이걸로 씨름할 시간에 많이 쓰고 기본적인것 복습하는것이 낫다. 일반인이 양자역학 다큐멘터리 보는꼴.
[자바스크립트는 왜 프로토타입을 선택했을까?](https://medium.com/@limsungmook/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%99%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EC%84%A0%ED%83%9D%ED%96%88%EC%9D%84%EA%B9%8C-997f985adb42)
  요약 : 현실에 존재하는 것 중 가장 좋은 본보기를 원형(prototype)으로 선택한다.
        문맥에(컨텍스트)에 따라 '범주', 즉 '의미'가 달라진다.
        자바스크립트는 근본적인 디자인 철학이 프로토타입이다.

* 쉬운 개념
    - 자바스크립트는 프로토타입을 통해 상속의 개념을 구현하고있다.
    - 객체.속성  으로 접근했을때 자기가 그 값이 없다면 자바스크립트는 그것이 프로토타입에는 있는지 확인한다.
    "느그아부지 뭐하시노? " 상속을 받을수있는놈인지 체크합니다.
    없으면 또 부모. 없으면 그놈의 부모. 계속 타고 올라간다. 그렇게해서 있다면, 나한테 없지만 부모에게 있는 그것을 사용할 수 있다.
    "느그 고조 할애비꺼 쓰면 되겠네" 이렇게 타고올라가는것을 프로토타입체인.  이것으로 상속을 구현.
    ```JavaScript
    자, 그럼 여기서
    let zoo = ["tiger", "lion", "rabbit"];
    zoo.sort(), zoo.length();
    이런걸 어떻게 쓸수있었을까요?

    let zoo = new Array("tiger", "lion", "rabbit");
    로 만든것이 된것이고, Array 또는 Array에 부모에 그 기능이 있는것.
    Array.prototype 쳐보세요.
    ```

    [MDN의 sort설명](https://developer.mozilla.org/ko/docs/orphaned/Web/JavaScript/Reference/Global_Objects/Array/sort)
    - **모든 객체는 사실 prototype이라는 속성을 가진다.** 그말은 나의 prototype도 prototype을 가지고있고 이것이 반복된다. 결국 null을 prototype으로 가지는 Object에서 끝이난다. 즉, 애미애비없는 Object가 바로 모든것의 부모. 태초의 객체.
    - 클래스는 객체를 생성할때마다 동일한 함수를 매번 생성하지만 프로토타입은 하나로 공유한다.

* 어려운 개념
    - 자바스크립트는 함수가 일급객체이기 때문에 함수도 속성을 가질수 있다. 그렇기 때문에 모든함수에도 prototype이라는 속성이 있다.
    - 사실, 자바스크립트는 함수가 정의되면, 그 이름의 '객체'가 생성되고 (위에서 한 말)
    **그 객체의 프로토타입 객체를 또 생성**하고 있었다.
    즉, '나'는 prototype이라는 프로퍼티가 있고 그것은 '나의 본질'라는 나의 프로토타입 객체를 가리킨다.
    그다음에, '나의 본질'도 '나'에 소속되어있다는 것을 알리기 위해서 costructor 라고 하는 프로퍼티를 자동으로 만들고 '나'를 가르키게 된다. 상호참조.
    - 부모라고 이해해서는 곤란하다. 말그대로 원형이라고 해석해야한다. 나의 부모가 아니라 나의 원형

* prototype 과 __proto__ 의 관계
    ![프로토타입](./프로토타입그림.png)


* 자식함수가 부모의 프로토타입을 상속받기 위해 해야하는것
    1. 자식함수내에서 부모함수를 call하여 부모객체를 리턴받는다.
    2. 자식의 프로토타입 객체를 부모의 프로토타입 객체로 설정
    안하면 Object임. 이자식은 이부모를 상속받았음을 프로토타입 체이닝을통해 알려주는 것.
    1. 자식의 프로토타입 객체가 참조하는 생성자도 부모로 설정
* 장점 : 메모리 절약
* 단점 : 참조를 저장하기 때문에 부모프로토타입의 속성이 바뀌면 이를 상속받은 자식 모두에게 영향을 줌.( 어떻게 보면 장점)

* 코드로 설명
```javascript
let Person = function(){
    this.a = 1;
    this.b = 2;
}
let kim = new Person();  //a:1, b:2
Person.prototype.b = 3;      //Person.b:2  이지만 Person.prototype.b :3
Person.prototype.c = 4;      //human의 프로토타입에 c라는 속성이 추가되고 값이 4가됨.

console.log(kim.a);   //1
console.log(kim.b);   //2
console.log(kim.c);   //4
console.log(kim.d);   //undefined

//그리고 현재의 kim는 Person으로부터 받은 a:1, b:2가 있고, Person의 prototype으로 부터 받은 b:3, d:4 이 있다.
console.log(kim.prototype);  //undefined
console.log(kim.__proto__);  //undefined  이지만 b:3, c:4, constructor : human
console.log(kim.__proto__.b); //그래서 3
```


---
#### FORM(폼)
[MDN주소](https://developer.mozilla.org/ko/docs/Web/HTML/Element/form)
- 폼태그
    - 사용자로부터 데이터를 입력받아 서버에 보낼때 사용. HTTP프로토콜을 사용.
    - **HTTP** : HyperText Transfer Protocol
    인터넷에서 웹서버와 클라이언트(브라우저)간에 문서를 전송하기 위해 사용되는 통신규약. **요청(request)**과 **응답(response)**으로 이루어졌다.
    - 요청을 받는 서버측은 JSP, Servlet, ASP, ASP.NET, PHP, RUBY, PYTHON 등의 언어를 사용한다.
    - 프론트는 id로 선택하고 서버측에서는 name으로 선택한다.

- 폼태그의 속성
    - name : 폼을 식별하기 위한 이름
      - submit이 되면 form 태그내의 모든 name들의 이름으로 넘어간다. reload가 되는 현상이 있으니 유의해야 한다.
    ```javascript
    <form onsubmit="submitFunction(event)">
    function submmitFunction(event){
        event.preventDefault();
        ~~ 필요한 부분 ~~
    }
    ```
    - target : 현재창, 새창
    - accept-charset : 문자 인코딩
    - action : 수신대상. 서버로 전송한 데이터를 수신할 URL
    - method : 전송방법. 데이터를 전송할 방식
        - get : (네이버에서 form태그 키워드로 전송하고 url이 어떻게 바뀌나 살펴보기.   ?와 =과  &)
        "이보시게 서버. 난 이러한 리소스들을 원하네"
        예) http://localhost:8080/form.jsp?name=joon&address=suwon
        body는 비어있고 url에 데이터를 태워서 파라미터의 형태로 전송.(=쿼리스트링)
        전송가능한 정보의 길이가 제한
        정보가 노출

        - post : HTTP프로토콜의 BODY에 담겨서 전송
        "이보시게 서버. 이 데이터를 보고 이거에 맞