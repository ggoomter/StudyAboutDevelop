# 정의
- 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용수 있는 재사용 가능한 솔루션.
- 역사적으로 위대한 개발자들이 특정 상황을 해결하는데 가장 좋다고 정석적으로 합의본 패턴
- 주로 객체지향 설계에 관한것이고, 대부분 객체지향적 설계원칙을 이융해 문제를 해결한다.
클래스 상속과 오브젝트 합성.
- 디자인패턴에서 가장 중요한 것은 '각 패턴의 핵심이 담긴 목적 또는 의도'
즉 패턴을 적용해야될 상황, 해결해야 할 문제, 솔루션의 구조와 각 요소의 역할, 핵심 의도를 아는것.
<장점>
- 디자인패턴 이름을 언급하는 것만으로도 설계의 의도와 해결책을 함께 설명할 수 있다.
<추천>
GoF의 디자인 패턴(에릭 감마 외)
Head First Design Patterns(에릭 프리먼)


### 템플릿 메소드 패턴  ### Template Method
- 정의
  슈퍼클래스에 기본적인 로직(공통, 변하지않는)의 흐름을 만들고,
  자주변경되며 확장할 기능은 추상메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤
  서브클래스에서 오버라이딩으로 구현해서 사용하도록 하는 방법.


### 팩토리 메소드 패턴  ### Factory Method
- 정의
서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 방법
복잡한 데이터구조를 순회하거나 순차적으로 이동하는 API를 제공한다.
- 목적
비슷한 객체들을 공장처럼 생성하는 것
개발자가 구체적인 타입을 모르고도 객체를 생성할 수 있게 한다.
- 예
var beetles = CarMaker.factory('Compact')

### 싱글톤 패턴 ### Singleton
- 정의
어떤 클래스를 애플리케이션 내에서 제한된 인스턴스 개수를 강제하는 패턴.
이름처럼 주로 하나만 존재하도록 한다.
- 이렇게 하나만 만들어진 클래스의 오브젝트는 애플리케이션 내에서 전역적으로 접근이 가능하며 이를 애플리케이션의 여러곳에서 공유하는 경우에 주로 사용한다.
- 컴파일때부터 메모리용량을 미리 알 수 있게 딱 정해져있기 때문에 static(정적요소)이라 불린다.
- 정적 변수를 쓰지 왜 싱글턴을 쓸까?  인터페이스의 사용, lazy loading 등 싱글톤으로 할 수 있는것이 더 많기 때문
- 디자인 패턴 중에서 가장 자주 활용되는 패턴이기도 하지만 가장 많은 비판을 받는 패턴이기도 하다. 심지어 디자인 책을 쓴 GoF멤버조차도 싱글톤패턴은 매우 조심해서 사용해야 하거나 피해야 할 패턴이라고 말하기도 한다. 가장 큰 이유는 멀티쓰레드 환경에서 오류가 발생할 소지들이 있기 때문. 안전하게 사용할 수 있는방법들을 익혀야 한다.
- 구현방법
1. 생성자를 private으로 만든다.
2. 자신과 같은 타입의 static 필드를 정의한다.
3. static factory 메소드인 getInstance()를 만들고 이 메소드가 최초로 호출되는 시점 한번만 오브젝트가 만들어지게 한다. 생성된 오브젝트는 스태틱 필드에 저장된다. 또는 스태틱 필드의 초기값으로 오브젝트를 미리 만들어둘 수도 있다.
4. 한번 오브젝트가 만들어지고 난 후에는 getInstance()메소드를 통해 이미 만들어져서 스태틱 필드에 저장해둔 오브젝트를 넘겨준다.
- 단점
  - 생성자가 private이고 자기자신만이 자기오브젝트를 만들기때문에 상속할 수 없다.
  - 만들어지는 방식이 제한적이기 때문에 테스트에서 사용될 때 해당상태의 오브젝트로 테스트하기 힘들다.
  - 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.
  - 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.
- 스프링의 싱글톤패턴
  - 싱글톤 레지스트리를 통해 스태틱메소드와 private 생성자를 사용해야 하는 비정상적인 클래스가 아니라 평범한 자바 클래스를 싱글톤으로 활용하게 해준다.
  - 싱글톤 방식으로 사용될 애플리케이션 클래스라도 public 생성자를 가질 수 있다.
  - 일반적인 싱글톤 패턴과 달리 스프링이 지지하는 객체지향적인 설계 방식과 원칙, 디자인 패턴 등을 적용하는데 아무런 제약이 없다.

### 빌더 패턴   ### Builder


### 데코레이터 패턴  ### Decorator
- 어떤 컴퍼넌트를 상속받은놈을 상속받기위한 목적으로 커스텀마이징해서 다른놈에서 상속받아 구현하는것
- 즉, 상속받아서 자식에서 구현하는게 아니라 또 상속받을 추가된 부모객체를 만드는것
- 자바의 입출력 스트림이 데코레이터 패턴임
- 상속보다 유연한 구현 방식
- 데코레이터는 다른 데코레이터나 컴포넌트를 포함해야함
- 지속적인 기능의 추가와 제거가 용이함
- 예) 기본 크리스마스트리, 불빛이 나는 트리, 꽃이 달린 트리 등


### 전략 패턴  ### Strategy Pattern
- 검색할때 전체, 이미지, 뉴스, 블로그, 지도 등에서 무엇을 선택하느냐에 따라 검색 방식이 다르게 결정되는것과 같다.
- 이 패턴이 없었을때의 개발방법
  1. 모드를 저장할 변수
  2. 해당 버튼을 클릭하면 변수의 값 변경
  3. 해당 변수의 값에 따라 분기처리하여 다른 내용 작성
  문제 : 새로운 조건이 생기거나 새로운 기능이 추가되거나 하면 분기처리하는 함수 내용을 수정해야 한다.
  -> 소프트웨어가 커지고 복잡해질수록 유지보수가 어렵게된다.
  -> 전략패턴은 모듈을 갈아끼우는 방식으로 개발한다.

- 인터페이스를 만들고 구현체들을 여려개 만든다음 호출하는쪽에서 setter로 다른 검색전략으로 갈아끼우는 방식.
  수정이 일어난다면 해당클래스만 수정하면되고, 새로운 조건이 추가되면 인터페이스를 구현한 새로운 클래스를 만들어주면 된다.

### State 패턴
- 전략패턴과 비슷한데 전략패턴이 지정된 특정 메소드가 모듈화된 모드에 따라 다르게 실행되도록 하는 것이라면, State패턴은 그 메서드가 실행될때 모드도 전환되도록 하는 것


### Command 패턴  ### 커맨드 패턴
- 전략패턴과 비슷한데 전략패턴이 '같은 일을 하되 그 알고리즘이나 방식이 갈아끼워지는 것' 이라면, 커맨드 패턴은 '그 하는일 자체가 다른 것'


### Adapter 패턴  ### 어답터 패턴
인터페이스가 서로다른 객체들이 같은 형식아래 작동할 수 있도록 하는 역할
<예제>
요리사 5명인 곳에서 바쁜일이 생겨서 파티쉐를 1명 고용하게 되었다. 일이 바쁘기 때문에 파티쉐에게 따로 '제과'해주세요라고 지시할수 없다.
그러나 파티쉐님은 앞으로 '요리'해주세요. 라고 들으면 '제과'를 해주시면 됩니다.
매니저는 편하게 '요리'해달라고만 지시하면 된다.

<구현방법>
요리하는 함수안에 다른인터페이스의 구현체를 생성자로 생성해서 해당인터페이스의 함수를 호출

### 프록시 패턴    ### Proxy 패턴
어지간한일은 앞에서 처리하는 대리인을 두는것. 

<예제>
유튜브 리스트에서 제목 섬네일이 떠있다가 마우스 커서가 올라가면 프리뷰가 재생됨

<구현방법>
간단한 일은 프록시역할을 하는 클래스가 처리하고, 중요한일은 비로소 본래 클래스가 처리하도록

### 퍼사드 패턴 ### Facade 패턴
> 건물의 정면을 의미
<설명>
소프트웨어의 커다란 부분에 대하여 간략화된 인터페이스를 제공해준다.
<왜 사용하는가>
하나의 메서드는 하나의 일만 하는것이 좋지만,
두개이상의 메서드가 함께 호출되는 경우가 많다면 이런 메서드호출들을 하나로 묶어주는 새로운 메서드를 만들어서 좀더 편리한 API를 제공하는것이 좋기 때문에
<구현방법>
설명할 필요없이 위의 why만 알아도 해결됨.

