# 불편
발음, 인텔리제이 사용법, 설정법, jdk 16으로 세팅돼있던거, 맥으로 하는거
옛날에 찍어놓은 듯한 화질, 영상에 노이즈
아.. 코틀린이 아니죠를 도대체 몇번하노


# 대용량 시스템을 만들기 위해 알아야 하는것
Spring, Mysql, MongoDB, Redis, Kafka, MSA
그러나 서버개발자의 핵심은 데이터
"어떻게 많은 양의 데이터를 안정적으로 CRUD할것인가"

## 기술
정규화, 인덱스, 트랜잭션, 동시성제어

# 꼭 해야하는것
부하 테스트.  feat. ngrinder, jmeter 등

# 실습환경
- mysql community 8.0 설치
  cmd에서 mysql -u root -p
  비번은 항상하던거 XXXnnnn
- [brew설치](https://brew.sh/index_ko)
  홈브루는 맥용 패키지 관리자
- 인텔리제이
- 테이블생성 create database fast_sns;
- 앱 다운(깃헙클론)  : https://github.com/koogk7/fastcampus-mysql/tree/init/project  
  집파일 다운로드
- 인텔리제이에서 mysql 연동
오른쪽위 open . 다운받은 프로젝트 선택. 
오른쪽 Database 탭 - Mysql선택 - driver file 다운로드,   입력정보 넣고 연결 테스트, 
- 앱의 src/main/resources/application.properties 열기
${url} 지우고 mysql 엔드포인트와 연결.   예) localhost:3306/fast_sns
mysql비번 입력
- 실행
  SpringApplication Run
  웹에서 http://localhost:8080/swagger-ui.html 접속    강의에는 http://localhost:8080/swagger-ui/ 라고 돼있음
  hello API 수행
- 테이블생성은 소스의 schema폴더의 ddl.sql
  Database 탭에서 인스턴스 우클릭 - Navigation - Jump to Query Console
  또는 DB Browser의 Consoles의 Connection 


# 인텔리제이
ctrl alt s : 세팅
ctrl alt shift s : 프로젝트 세팅
Smart tomcat설치 https://jyj98020.tistory.com/m/353
view에서 툴바보이기 체크
한글설정 
인코딩설정
오른쪽에 gradle 탭이 있어서 reload
<에러>
invalid source release: 16 에러
  build.gradle에서 16을 내버전으로 변경 -> 이후에 Record써서 다시 16으로 변경함
  - 프로젝트 세팅(ctrl alt shift s) - Project - Project SDK와 Project Language level 에서 jdk설정
  - 인텔리제이세팅(ctrl alt s) - gradle검색 - 밑의 Gradle JVM 에서 jdk변경
Execution failed for task ':test'. 에러
  - 프로젝트 세팅 - gradle에서 Run tests using을 IntelliJ IDEA로 변경하라고 했지만 해도 안되다가 리로드하고 테스트직접 돌렸다가 다시 하니까 됨



# 웹의 기본 아키텍쳐
관심사의 분리 / 관측가능한 시스템 / 효율적인 리소스 사용 철학에 따라 
클라이언트 - 웹서버 - 웹어플리케이션서버 - 데이터베이스 아키텍처를 만드는데 
대용량 시스템에서는 게이트웨이, 캐시, 비동기큐, 데이터웨어하우스, 로그시스템, 매트릭수집서버, 전문검색 색인, 푸쉬서버 등을 구성한다.

# 왜 데이터베이스가 병목일까?
- 스케일업
  하나의 서버가 하던일을 좀더 크고좋은 서버로 분담
  유지보수 쉬움, 확장성의 제약, 장애시 다운타임이 있음
- 스케일아웃
  하나의 서버가 하던일을 여러개의 서버로 분담
  여러노드에 부하가 분산됨, 스케일업에 대해 자유로움, 장애 탄력성이 있음
- 대용량서비스에서는 스케일아웃이 더 적합하고 사용자 입장에서는 마치 하나의 서버처럼 보여야 한다. 그래서 여러대의 서버가 하나의 데이터베이스를 바라보고있어서 병목현상이 발생된다.
데이터베이스는 데이터라는 상태를 관리하고 있어야 하기 때문에 스케일아웃을 하기위해서는 서버보다 훨씬 더 큰 비용이 든다.
그래서 현대 서버 아키텍처는 상태관리를 데이터베이스에 위임하고 서버는 상태관리를 하지 않는 방향으로 발전하게 된다. 이로인해 서버는 자유롭게 스케일아웃하게 될수있게 된다.
데이터베이스는 디스크의 데이터를 접근해서 가져온다.



# 대용량 시스템이 어려운 이유
- 하나의 서버로 감당하기 힘들어 대부분 여러개의 서버 또는 데이터베이스를 사용함
- 그것들의 데이터의 일관성을 보장해야함
- 코드 한줄이 데이터에 미치는 영향범위가 굉장히 커짐
- 여러 마이크로 서비스들이 복잡한 의존관계로 얽혀있어 복잡도가 크다.

# 조건
고가용성 : 언제든 서비스를 이용할 수 있어야 한다.
확장성 : 시스템이 비대해짐에 따라 증가하는 데이터와 트래픽에 대응할 수 있어야 한다.
관측가능성 : 문제가 생겼을대 빠르게 인지할 수 있어야 하고, 문제의 범위를 최소화 할 수 있어야 한다.

# 맛보기
1. 클라이언트 - 서버 - 데이터 베이스에서
트래픽이 많아진다면
2. 서버를 늘리고 앞에 로드밸런서를 두기
대부분 라운드로빈 알고리즘으로 어느서버에 보낼지 결정
서버를 아무리 늘려도 데이터베이스에 접근 속도가 느려서 느린것을 극복못함
3. 캐시
글로벌 캐시를 적용할것인지 로컬 캐시를 적용할것인지 고민
캐시 주기, 만료 정책은 어떻게 할것인가 고민
그러나 이메일, 알림 등 대외기관과의 연동이 필요한 서비스가 늘어나고, 그것들의 응답속도는 우리가 조절할 수 없음
4. 비동기큐


# mysql을 학습해야 하는 이유
### 데이터베이스들의 종류
Document DB, 전문색인 DB, 관계형 DB, Graph DB, Wide column DB, Key value DB
2022년 데이터베이스 랭킹 : https://db-engines.com/en/ranking
  1위부터4위까지 관계형 데이터베이스. Oracle, MySQL, MS SQL, PostgreSQL
  관계형 데이터베이스 안에서도 여러 데이터베이스들이 있다.
  mysql은 가장 인기가 많은 오픈소스형 관계형 데이터베이스이며, 높은 접근성과 낮은 비용,   네이버-카카오-토스 등 국내 IT기업에서도 많이 사용, SQL ANSI표준을 지키고있음

'mysql엔진'은 판단과 명령을 하는 두뇌
  - 쿼리파서 : SQL을 파싱하여 Syntax Tree를 만듦. 문법 오류검사
  - 전처리기 : 쿼리파서에서 만든 신택스 트리를 바탕으로 전처리. 테이블과 컬럼의 존재여부, 접근권한 등 시멘틱 오류 검사
    //쿼리파서와 전처리기는 컴파일 과정과 매우 유사하나, 프로그래밍언어처럼 컴파일 타임때 검증할 수 없어서 매번 구문 평가를 진행
  - 옵티마이저 : 쿼리를 처리하기 위한 여러 방법들을 만들고, 비용정보와 테이블의 통계정보를 이용해 비용을 산정 후 전략을 결정(실행계획수립)
            옵티마이저가 항상 최적의 판단을 하는것이 아니기 때문에 개발자가 힌트를 사용해 도움을 줄 수 있다.
  - 쿼리실행기 : Handler API를 통해 스토리지 엔진에 요청

'스토리지엔진'은 수행하는 팔과 다리
  - 디스크에서 데이터를 가져오거나 저장하는 역할
  - Handler API만 맞춘다면 직접 구현해서 사용할 수 있다.
  - InnoDB, MyIsam 등 여러 스토리지 엔진이 존재하고 8.0부터는 InnoDB엔진이 디폴트

'캐시'
    - Mysql 5.0까지는 '쿼리 캐시'라는 것이 있었고 8.0대 폐기됨. SQL과 데이터를 매핑해서 똑같은 요청이라면 캐시해둔 데이터 사용. 
    - 테이블의 데이터가 변경이 되면 캐시된 데이터도 같이 변경해야되는데 그때 lock과 같은 이슈들로 인해서 이점보다 문제가 더 많다고 판단했기 때문
    - 오라클에는 '소프트파싱'이 존재한다. : 데이터를 캐싱하는것이 아니라 옵티마이저(실행계획) 까지만 캐싱
    - 캐시를 도입할때는 항상 만료정책을 고려해야 한다.
    - 모든 기술은 트레이드오프다.

#### InnoDB의 핵심 키워드
Clustered Index, Redo-Undo, Buffer pool

## 정규화
중복을 최소화 하게 데이터를 구조화하는 프로세스
"테이블 설계관점에서 조회와 쓰기 사이의 트레이드 오프"
정규화 : 쓰기의 성능을 높이기 위해 읽기의 성능을 버림. 중복을 제거하고 한곳에서 관리. 데이터 정합성. 읽기시 참조가 필요.
반정규화 : 읽기의 성능을 높이기 위해 쓰기의 성능을 버림. 중복을 허용.  데이터 정합성 유지 안됨.  참조없이 읽기 가능



# 공부해야되는거
NamedParameterJdbcTemplate
@RequiredArgsConstructor
jdbc template