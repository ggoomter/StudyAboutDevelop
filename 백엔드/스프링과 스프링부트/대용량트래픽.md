# 불편
발음, 인텔리제이 사용법, 설정법, jdk 16으로 세팅돼있던거, 맥으로 하는거
옛날에 찍어놓은 듯한 화질, 영상에 노이즈
아.. 코틀린이 아니죠를 도대체 몇번하노


# 대용량 시스템을 만들기 위해 알아야 하는것
Spring, Mysql, MongoDB, Redis, Kafka, MSA
그러나 서버개발자의 핵심은 데이터
"어떻게 많은 양의 데이터를 안정적으로 CRUD할것인가"

## 기술
정규화, 인덱스, 트랜잭션, 동시성제어

# 꼭 해야하는것
부하 테스트.  feat. ngrinder, jmeter 등

# 실습환경
- mysql community 8.0 설치
  cmd에서 mysql -u root -p
  비번은 항상하던거 XXXnnnn
- [brew설치](https://brew.sh/index_ko)
  홈브루는 맥용 패키지 관리자
- 인텔리제이
- 테이블생성 create database fast_sns;
- 앱 다운(깃헙클론)  : https://github.com/koogk7/fastcampus-mysql/tree/init/project  
  집파일 다운로드
- 인텔리제이에서 mysql 연동
오른쪽위 open . 다운받은 프로젝트 선택. 
오른쪽 Database 탭 - Mysql선택 - driver file 다운로드,   입력정보 넣고 연결 테스트, 
- 앱의 src/main/resources/application.properties 열기
${url} 지우고 mysql 엔드포인트와 연결.   예) localhost:3306/fast_sns
mysql비번 입력
- 실행
  SpringApplication Run
  웹에서 http://localhost:8080/swagger-ui.html 접속    강의에는 http://localhost:8080/swagger-ui/ 라고 돼있음
  hello API 수행
- 테이블생성은 소스의 schema폴더의 ddl.sql
  Database 탭에서 인스턴스 우클릭 - Navigation - Jump to Query Console
  또는 DB Browser의 Consoles의 Connection 


# 인텔리제이
ctrl alt s : 세팅
ctrl alt shift s : 프로젝트 세팅
Smart tomcat설치 https://jyj98020.tistory.com/m/353
view에서 툴바보이기 체크
한글설정 
인코딩설정
오른쪽에 gradle 탭이 있어서 reload
<에러>
invalid source release: 16 에러
  build.gradle에서 16을 내버전으로 변경 -> 이후에 Record써서 다시 16으로 변경함
  - 프로젝트 세팅(ctrl alt shift s) - Project - Project SDK와 Project Language level 에서 jdk설정
  - 인텔리제이세팅(ctrl alt s) - gradle검색 - 밑의 Gradle JVM 에서 jdk변경
Execution failed for task ':test'. 에러
  - 프로젝트 세팅 - gradle에서 Run tests using을 IntelliJ IDEA로 변경하라고 했지만 해도 안되다가 리로드하고 테스트직접 돌렸다가 다시 하니까 됨



# 웹의 기본 아키텍쳐
관심사의 분리 / 관측가능한 시스템 / 효율적인 리소스 사용 철학에 따라 
클라이언트 - 웹서버 - 웹어플리케이션서버 - 데이터베이스 아키텍처를 만드는데 
대용량 시스템에서는 게이트웨이, 캐시, 비동기큐, 데이터웨어하우스, 로그시스템, 매트릭수집서버, 전문검색 색인, 푸쉬서버 등을 구성한다.

# 왜 데이터베이스가 병목일까?
- 스케일업
  하나의 서버가 하던일을 좀더 크고좋은 서버로 분담
  유지보수 쉬움, 확장성의 제약, 장애시 다운타임이 있음
- 스케일아웃
  하나의 서버가 하던일을 여러개의 서버로 분담
  여러노드에 부하가 분산됨, 스케일업에 대해 자유로움, 장애 탄력성이 있음
- 대용량서비스에서는 스케일아웃이 더 적합하고 사용자 입장에서는 마치 하나의 서버처럼 보여야 한다. 그래서 여러대의 서버가 하나의 데이터베이스를 바라보고있어서 병목현상이 발생된다.
데이터베이스는 데이터라는 상태를 관리하고 있어야 하기 때문에 스케일아웃을 하기위해서는 서버보다 훨씬 더 큰 비용이 든다.
그래서 현대 서버 아키텍처는 상태관리를 데이터베이스에 위임하고 서버는 상태관리를 하지 않는 방향으로 발전하게 된다. 이로인해 서버는 자유롭게 스케일아웃하게 될수있게 된다.
데이터베이스는 디스크의 데이터를 접근해서 가져온다.



# 대용량 시스템이 어려운 이유
- 하나의 서버로 감당하기 힘들어 대부분 여러개의 서버 또는 데이터베이스를 사용함
- 그것들의 데이터의 일관성을 보장해야함
- 코드 한줄이 데이터에 미치는 영향범위가 굉장히 커짐
- 여러 마이크로 서비스들이 복잡한 의존관계로 얽혀있어 복잡도가 크다.

# 조건
고가용성 : 언제든 서비스를 이용할 수 있어야 한다.
확장성 : 시스템이 비대해짐에 따라 증가하는 데이터와 트래픽에 대응할 수 있어야 한다.
관측가능성 : 문제가 생겼을대 빠르게 인지할 수 있어야 하고, 문제의 범위를 최소화 할 수 있어야 한다.

# 맛보기
1. 클라이언트 - 서버 - 데이터 베이스에서
트래픽이 많아진다면
2. 서버를 늘리고 앞에 로드밸런서를 두기
대부분 라운드로빈 알고리즘으로 어느서버에 보낼지 결정
서버를 아무리 늘려도 데이터베이스에 접근 속도가 느려서 느린것을 극복못함
3. 캐시
글로벌 캐시를 적용할것인지 로컬 캐시를 적용할것인지 고민
캐시 주기, 만료 정책은 어떻게 할것인가 고민
그러나 이메일, 알림 등 대외기관과의 연동이 필요한 서비스가 늘어나고, 그것들의 응답속도는 우리가 조절할 수 없음
4. 비동기큐


# mysql을 학습해야 하는 이유
### 데이터베이스들의 종류
Document DB, 전문색인 DB, 관계형 DB, Graph DB, Wide column DB, Key value DB
2022년 데이터베이스 랭킹 : https://db-engines.com/en/ranking
  1위부터4위까지 관계형 데이터베이스. Oracle, MySQL, MS SQL, PostgreSQL
  관계형 데이터베이스 안에서도 여러 데이터베이스들이 있다.
  mysql은 가장 인기가 많은 오픈소스형 관계형 데이터베이스이며, 높은 접근성과 낮은 비용,   네이버-카카오-토스 등 국내 IT기업에서도 많이 사용, SQL ANSI표준을 지키고있음

'mysql엔진'은 판단과 명령을 하는 두뇌
  - 쿼리파서 : SQL을 파싱하여 Syntax Tree를 만듦. 문법 오류검사
  - 전처리기 : 쿼리파서에서 만든 신택스 트리를 바탕으로 전처리. 테이블과 컬럼의 존재여부, 접근권한 등 시멘틱 오류 검사
    //쿼리파서와 전처리기는 컴파일 과정과 매우 유사하나, 프로그래밍언어처럼 컴파일 타임때 검증할 수 없어서 매번 구문 평가를 진행
  - 옵티마이저 : 쿼리를 처리하기 위한 여러 방법들을 만들고, 비용정보와 테이블의 통계정보를 이용해 비용을 산정 후 전략을 결정(실행계획수립)
            옵티마이저가 항상 최적의 판단을 하는것이 아니기 때문에 개발자가 힌트를 사용해 도움을 줄 수 있다.
  - 쿼리실행기 : Handler API를 통해 스토리지 엔진에 요청

'스토리지엔진'은 수행하는 팔과 다리
  - 디스크에서 데이터를 가져오거나 저장하는 역할
  - Handler API만 맞춘다면 직접 구현해서 사용할 수 있다.
  - InnoDB, MyIsam 등 여러 스토리지 엔진이 존재하고 8.0부터는 InnoDB엔진이 디폴트

'캐시'
    - Mysql 5.0까지는 '쿼리 캐시'라는 것이 있었고 8.0대 폐기됨. SQL과 데이터를 매핑해서 똑같은 요청이라면 캐시해둔 데이터 사용. 
    - 테이블의 데이터가 변경이 되면 캐시된 데이터도 같이 변경해야되는데 그때 lock과 같은 이슈들로 인해서 이점보다 문제가 더 많다고 판단했기 때문
    - 오라클에는 '소프트파싱'이 존재한다. : 데이터를 캐싱하는것이 아니라 옵티마이저(실행계획) 까지만 캐싱
    - 캐시를 도입할때는 항상 만료정책을 고려해야 한다.
    - 모든 기술은 트레이드오프다.

#### InnoDB의 핵심 키워드
Clustered Index, Redo-Undo, Buffer pool

## 정규화
중복을 최소화 하게 데이터를 구조화하는 프로세스
장점 : 한곳에서만 관리하고 있으면 부정합이 일어나지 않는다.
단점 : 읽을때는 항상 원본 데이터를 참고해야 한다.
"테이블 설계관점에서 조회와 쓰기 사이의 트레이드 오프"
정규화 : 쓰기의 성능을 높이기 위해 읽기의 성능을 버림. 중복을 제거하고 한곳에서 관리. 데이터 정합성. 읽기시 참조가 필요.
반정규화 : 읽기의 성능을 높이기 위해 쓰기의 성능을 버림. 중복을 허용.  데이터 정합성 유지 안됨.  참조없이 읽기 가능

## 비정규화
중복을 허용
데이터정합성 유지가 어려움
참조없이 읽기 가능


<정규화 비정규화의 판단>
정규화 자체도 비용이다. 읽기 비용을 지불하고 쓰기 비용을 줄이는 것
중복이 일어나면 무조건 정규화를 해야하는 것 아니다.
- 얼마나 빠르게 데이터의 최신성을 보장해야 하는가?
- 히스토리성 데이터는 오히려 정규화를 하지 않아야 한다. 당연한것
- 데이터 변경 주기와 조회 주기는 어떻게 되는가?
- 객체(테이블) 탐색 깊이가 얼마나 깊은가

<정규활르 하기로 했다면 읽기시 데이터를 어떻게 가져올 것인가?>
- 테이블 조인을 많이 활용하는데, 이건 사실 고민해볼 문제. 
  왜냐하면 조인은 서로 다른 테이블의 결합도를 엄청나게 높이기 때문
- 조회시에는 성능이 좋은 별도 데이터베이스나 캐싱 등 다양한 최적화 기법을 이용할 수 있다.
- 조인을 사용하게 되면, 이런 기법들을 사용하는데 제한이 있거나 더 많은 리소스가 들 수 있다.
- 읽기 쿼리가 한번 더 발생되는 것은 그렇게 큰 부담이 아닐 수 있다.

# 데이터베이스 성능 핵심
## 인덱스
- 디스크는 메모리보다 훨씬 느리다.
- **데이터베이스 성능의 핵심은 디스크 I/O를 최소화 하는 것**
- 어떻게 줄일수 있을까?
  - 메모리에 올라온 데이터로 최대한 요청을 처리하는 것
    = 메모리 캐시 히트율을 높이는 것
- 메모리에 데이터 유실을 고려해 WAL(Write Ahead Log)를 사용
  - 메모리에 쌓아뒀다가 한번에 써주자.
  - 유실되더라도 파일에 히스토리가 있어서 서버가 다시 뜰때 재실행하는 방식으로 정합성 유지
- **인덱스의 핵심은 탐색(검색) 범위를 최소화 하는 것**
- 인덱스필드에 뭔가 가공이 들어가게 되면 인덱스를 탈수가 없다.

<자료구조>
- 해쉬맵
  - 단건검색속도는 O(1)
  - 범위탐색은 O(n)
  - 전방일치 탐색 불가.   예를들어 like 검색
- 리스트
  - 정렬되지 않은 리스트의 탐색은 O(n)
  - 정렬된 리스트의 탐색은 O(log N)
  - 정렬되지 않은 리스트의 정렬 시간 복잡도는 O(n) ~ O(nlogn)
  - 삽입/삭제 비용이 매우 높음
- 트리
  - 트리 높이에 따라 시간복잡도가 결정됨  //바이너리 서치를 이용한다면
  - 트리의 높이를 최소화하는 것이 중요
  - 한쪽으로 노드가 치우치지 않도록 균형을 잡아주는 트리 사용
    예) 레드블랙트리, B+트리
- B+트리
  - 대부분의 RDBMS에서 사용
  - 삽입/삭제시 항상 균형을 이룸
  - 하나의 노드가 여러개의 자식 노드를 가질 수 있음
  - 리프노드에만 데이터 존재
    - 연속적인 데이터 접근시 유리


- 오라클은 인덱스키에 값으로 pk가 아니라 주소가 있다.
- mysql은 인덱스키에 값으로 pk가 있다. 그래서 데이터를 찾아 갈 수 없다. 
- **인덱스를 쓴다는것은 조회의 성능을 높이지만 삽입, 수정, 삭제의 성능은 낮아질 수 밖에 없다. 모든것은 트레이드 오프다.**


### 클러스터, 논클러스터 인덱스
- 클러스터 인덱스는 데이터 위치를 결정하는 키 값이다.
- Mysql의 pk는 클러스터 인덱스다.
- Mysql에서 pk를 제외한 모든 인덱스는 pk를 가지고 있다.


클러스터 인덱스
  개념 : 테이블당 한개만 생성 가능
        정렬된 순서에 따라 데이터의 주소가 결정된다.
        인덱스 자체가 책의 내용과 같음. 인덱스 자체에 데이터가 포함되어 있다.
  장점 : pk를 활용한 검색이 빠름. 특히 범위 검색
        세컨더리 인덱스들이 pk를 가지고 있어 커버링에 유리
  단점 : 

논클러스터 인덱스
  개념 : 테이블당 여러개를 생성 가능
        찾아보기가 있는 일반 책과 같다.
  장점 : 
  단점 : 

### pk로 Auto Increment vs UUID
pk는 삽입 및 갱신시 정렬이 항상 일어나야 된다는것을 상기하며 생각해보자.

## 성능테스트를 위한 게시블 벌크 인서트
100만건정도
이지랜덤 기능
import org.jeasy.random.EasyRandom;
var param = new EasyRandomParameters();




# 공부해야되는거
NamedParameterJdbcTemplate
@RequiredArgsConstructor
jdbc template